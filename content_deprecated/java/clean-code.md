---
title: "클린코드 관리하기"
date: 2020-01-16T01:17:18+03:00
draft: false
---

본 문서는 클린코드를 위한 중요 원칙 **5가지**를 경험에 기반해 요약했습니다.



### 1. 네이밍 컨벤션 준수

구글의 [자바 가이드](https://google.github.io/styleguide/javaguide.html) 와 같은 사례를 참조 하면 좋습니다. 관례적으로 네이밍 컨벤션은 다음과 같은 원칙을 따르는 것이 좋습니다.



- **클래스**명은 명사를 사용하며 의미가 드러나는 이름을 짓습니다.
- **변수**는 의도가 드러나는 작성합니다.
- **메서드**는 객체의 동작을 의미하므로 동사를 사용하여 이름을 짓습니다.
- 멤버 벼수, 인자명, 로컬 변수명은 **lowerCamelCase** 방식을 따릅니다.
- 상수 변수명은 CONTANT_CASE 방식을 이용합니다.



```
// Constants
static final int NUMBER = 5;
static final ImmutableList NAMES = ImmutableList.of("Ed", "Ann");
```



### 2. 주석 관리

불필요한 주석을 제거하고 의도를 명확하게 관리합니다.



#### 2.1 중복 주석 제거

코드로서 의도를 직관적으로 파악할 수 있다면 주석을 남기지 않아도 됩니다.

```
ProcessBuilder builder = new ProcessBuilder("notepad.exe"); 
Process pro = builder.start();
```

제거 해야할 주석도 있지만 좋은 주석도 있습니다. 이후 소개할 주석 유형들에 해당합니다.



#### 2.2 정보 제공 주석

코드에서 강조할 부분이 있거나,  의도를 직관적으로 파악할 수 없다면 정보 제공 주석을 남겨야 합니다.

```
private void quicksort(int low, int high) {
        int i = low, j = high;
        // 리스트 중간의 피봇 엘리먼트의 위치
        int pivot = numbers[(low + high) / 2];
        // 하나의 리스트를 두개의 리스트로 나눔
        while (i <= j) {
        ..
}
```



#### 2.3 할일 주석

할일 주석은 차기 기능 요소 추가시 유용하게 사용 가능합니다.

```
// TODO 미사용 함수
public String getProgramName() {
     ...
     return nameOfProgram;
}
```



#### 2.4 경고 주석

경고 주석은 잘못된 코드 사용을 방지하고 Side Effect를 예방합니다.

```
 // WARN 암호화 모드 에서만 사용
 public void _getEncryptionResult() {
     ...
 }
```



### 3. 코드 복잡도 관리

좋은 개발자는 사람이 이해할 수 있는 코드를 만듭니다. 나쁜 개발자는 컴퓨터만 이해할 수 있는 코드를 작성합니다. 주기적인 리팩토링을 통해 점진적인 개선을 통해 낮은 복잡도의 코드가 되도록 합니다. 낮은 복잡도의 코드는 다음과 같은 특성이 있습니다.

- 간결한 코드
- 역할이 분명한 코드
- 형식을 갖춘 코드



#### 3.1 간결한 코드

레거코드를 지속적으로 리팩토링하여 간결한 코드가 되도록 합니다.



##### 함수 인자 최소화

함수 인자가 많으면 함수가 여러 관점의 일을 수행해 코드가 복잡해지고 동작 예측이 어려워집니다.



##### 중복 코드 제거

가급적 적은 코드가 유지 되도록합니다. 클래스는 다른데 역할이 동일한 메서드가 있다면 중복 코드로 제거합니다. 디자인 패턴은 중복 코드를 어떻게 제거 할지에 대한 초점이 있습니다.



##### 죽은 코드 제거

더이상 사용하지 않는 함수는 삭제합니다. 버전 코드 시스템이 기억하게 합니다.



#### 3.2 역할이 분명한 코드



##### 단일책임원칙

클래스는 **단일책임원칙**(SRP : Single Responsibility Principle)을 따라 한가지 역할 만을 수행 하도록 합니다. 만약 SRP원칙에 위배되는 역할이 2개 이상 존재하는 클래스가 있다면 단일책임원칙을 수행하도록 새로운 클래스를 생성합니다. 이 원칙은 클래스 뿐 아니라 함수에도 동일하게 적용 가능합니다. 단일책임원칙을 지키다 보면 분리된 각 클래스의 결합도(coupling)가 낮아지고 응집도(cohesion)가 높아져 외부 결합도(**External coupling**)는 낮추고 내용 결합도(**Content coupling** 또는 **Pathological coupling**)는 높입니다.



#### 3.3 형식을 갖춘 코드



##### 적절한 행 길이

500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있습니다. 큰 파일 보다 작은 파일이 이해하기 쉽습니다. 적절한 행 길이를 유지해 코드 가독성을 높입니다. 함수도 최대한 작게 만듭니다. 한 함수당 3~5줄 정도로 줄이는 것이 좋습니다. 



##### 형식 길이

한 줄당 80~120자 정도의 길이로 제한하고 적절한 들여쓰기를 고려합니다.



##### 적절한 배치

서로 밀접한 개념은 한 파일에 세로로 가까이 둡니다. 변수는 사용하는 위치에서 가장 근접한 위치에 선언합니다.



### 4. 코드 품질 관리



#### 4.1 예외 관리

- 오류 코드보다 예외를 사용합니다.



#### 4.2 테스트 관리

- 버그 주변은 철저히 테스트하여 코드 안전성 확보
- 경계 조건 테스트
- 테스트 커버리지 높임 : 단위 테스트가 가능 하도록 테스트 가능한 코드를 작성 하려고 합니다.



### 5. 클린코드 원칙 적용



#### 5.1 보이스카우트 규칙

시간이 지날 수 록 코드가 지저해진다면 보이스카우트 규칙을 도입할 필요가 있습니다. 이 규칙은  **야영지는 그곳을 발견했을 때보다 떠날 때 더 나은 곳이어야 한다**는 규칙입니다.

```
"Leave the campground cleaner than you found it."
```

