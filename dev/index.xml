<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devs on 해피그의 코드랩</title>
    <link>https://happygrammer.github.io/dev/</link>
    <description>Recent content in Devs on 해피그의 코드랩</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Apr 2024 05:43:02 +0900</lastBuildDate>
    
	<atom:link href="https://happygrammer.github.io/dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM 메모리 구조 이해하기</title>
      <link>https://happygrammer.github.io/dev/java/understanding-jvm-memory-structure/</link>
      <pubDate>Fri, 12 Apr 2024 05:43:02 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/understanding-jvm-memory-structure/</guid>
      <description>JVM 메모리 구조 JVM(Java Virtual Machine)은 자바 프로그램을 실행하기 위한 가상 머신으로, 자바 코드를 바이트코드로 컴파일하고 이를 실행합니다. JVM은 메모리 관리를 위해 다양한 영역으로 구분되어 있으며, 이를 이해하는 것은 자바 개발자에게 중요한 역량입니다.
JVM 메모리는 크게 네이티브 영역과 VM 영역으로 나뉩니다. 네이티브 영역에는 텍스트, 데이터, 힙, 스택 등이 존재하며, 이는 일반적인 프로그램 실행에 필요한 메모리 영역입니다.
VM 영역은 자바 클래스를 구동하기 위한 전용 메모리 영역으로, 네이티브 영역과 유사한 역할을 수행합니다. VM 영역에는 다음과 같은 주요 메모리 영역이 있습니다:</description>
    </item>
    
    <item>
      <title>delimiter 종류와 선택 가이드</title>
      <link>https://happygrammer.github.io/dev/choosing-splitters-for-data-fields/</link>
      <pubDate>Wed, 03 Apr 2024 07:16:52 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/choosing-splitters-for-data-fields/</guid>
      <description>Delimiter(구분문자)는 데이터를 분할하거나 구분하는 데 사용되는 문자 또는 문자열을 말합니다. 주로 데이터를 필드 또는 열 단위로 나눌 때 사용됩니다. 예를 들어, &amp;ldquo;apple,banana,cherry&amp;quot;라는 문자열이 있을 때, 콤마(,)를 Delimiter로 사용하면 &amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;quot;의 세 부분으로 나눌 수 있습니다. 데이터를 다룰 때 각 필드를 명확하게 구분할 수 있는 적절한 Delimiter를 선택하는 것이 중요합니다. 좋은 Delimiter는 데이터의 가독성을 높이고, 데이터 처리 과정에서 오류를 줄이는 데 도움을 줍니다. 다음은 데이터 필드를 구분할 때 사용할 수 있는 Delimiter들입니다:</description>
    </item>
    
    <item>
      <title>자바스크립트 콜백 함수로 의존성 제거하기</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/removing-dependencies-with-callback-functions-in-javascript/</link>
      <pubDate>Tue, 02 Apr 2024 00:15:28 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/removing-dependencies-with-callback-functions-in-javascript/</guid>
      <description>자바스크립트에서 콜백 함수를 활용하면 의존성을 제거하고 코드의 재사용성을 높일 수 있습니다. 특히, 다른 메서드를 호출할 때 req와 res 객체를 직접 전달하는 대신 콜백 함수를 전달하는 방식은 많은 이점을 가져다 줍니다.
전통적인 방식에서는 한 메서드가 다른 메서드를 호출할 때 req와 res 객체를 인자로 전달합니다. 이는 메서드 간의 결합도를 높이고, 코드의 재사용성을 떨어뜨립니다. 또한, 메서드의 책임이 명확하지 않아 유지보수가 어려워질 수 있습니다.
반면에, 콜백 함수를 사용하면 이러한 문제를 해결할 수 있습니다. 호출되는 메서드는 req와 res 객체에 대한 의존성이 없어지고, 오직 콜백 함수를 통해서만 결과를 전달받습니다.</description>
    </item>
    
    <item>
      <title>심볼릭 링크 사용시 주의사항</title>
      <link>https://happygrammer.github.io/dev/linux/symbolic-link-caution/</link>
      <pubDate>Mon, 01 Apr 2024 23:36:13 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/symbolic-link-caution/</guid>
      <description>심볼릭 링크(Symbolic Link)는 유닉스 계열 운영체제에서 파일이나 디렉터리에 대한 참조를 만드는 방법입니다. 이를 통해 파일 시스템 내에서 파일이나 디렉터리를 여러 위치에서 접근할 수 있게 됩니다. 하지만 심볼릭 링크 사용에는 주의해야 할 사항이 있습니다.
첫째, 심볼릭 링크는 읽기 전용으로 관리하는 것이 좋습니다. 심볼릭 링크 자체를 수정하기보다는 원본 파일을 변경하는 것이 안전합니다. 이는 심볼릭 링크의 무결성을 유지하고, 예기치 않은 문제를 방지하는 데 도움이 됩니다.
둘째, 심볼릭 링크가 가리키는 원본 파일이 삭제되거나 이동되면 링크가 깨질 수 있습니다.</description>
    </item>
    
    <item>
      <title>학습셋 통계 내기</title>
      <link>https://happygrammer.github.io/dev/linux/analyze_dataset/</link>
      <pubDate>Sun, 31 Mar 2024 22:18:21 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/analyze_dataset/</guid>
      <description>머신러닝이나 자연어처리 프로젝트를 진행할 때, 학습셋에 대한 통계를 내는 것은 매우 중요합니다. 이를 통해 데이터의 분포를 파악하고, 모델 성능에 영향을 줄 수 있는 요인을 찾아낼 수 있기 때문입니다.
data.set와 같은 학습셋 파일에서 통계를 내기 위해 다음과 같은 쉘 명령어를 사용할 수 있습니다.
cut -f &amp;lt;tab_position&amp;gt; &amp;lt;file_name&amp;gt; | sort | uniq -c data.set 파일에서 마지막 탭(\\t) 값을 기준으로 각 값의 개수를 출력하려면 다음과 같이 명령을 입력합니다.
cut -f $(($(head -n1 data.set | tr -cd &#39;\t&#39; | wc -c)+1)) data.</description>
    </item>
    
    <item>
      <title>파이썬 for 루프 마스터하기</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-for-loops/</link>
      <pubDate>Sun, 31 Mar 2024 04:33:40 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-for-loops/</guid>
      <description>안녕하세요, 파이썬 개발자 여러분! 오늘은 리스트의 요소를 출력하는 다양한 종류의 for 루프 사용법에 대해 알아보겠습니다.
먼저, 주어진 리스트 a를 살펴봅시다.
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]  for-each 루프를 사용하여 리스트의 요소를 하나씩 출력할 수 있습니다.  for element in a: print(element, end=&#39; &#39;) print() 인덱스를 사용한 for 루프로 리스트의 요소에 접근할 수도 있습니다.  for i in range(len(a)): print(a[i], end=&#39; &#39;) print() while 루프와 인덱스를 활용하여 리스트의 요소를 출력할 수 있습니다.</description>
    </item>
    
    <item>
      <title>파이썬 컴프리헨션: 한 줄로 자료구조 다루기</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-comprehensions-for-concise-code/</link>
      <pubDate>Sun, 31 Mar 2024 04:25:40 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-comprehensions-for-concise-code/</guid>
      <description>안녕하세요, 파이썬 개발자 여러분! 오늘은 파이썬에서 자료구조를 더욱 효율적이고 간결하게 표현할 수 있는 컴프리헨션(Comprehension) 문법에 대해 알아보겠습니다.
컴프리헨션은 리스트, 딕셔너리, 세트 등의 자료구조를 생성할 때 사용할 수 있는 강력한 문법입니다. 간단한 예시를 통해 살펴보겠습니다.
먼저, 리스트 컴프리헨션을 사용하여 리스트 &amp;lsquo;a&#39;에서 2보다 큰 요소로 이루어진 새 리스트 &amp;lsquo;b&#39;를 생성해보겠습니다.
a = [1, 2, 3, 4] b = [i for i in a if i &amp;gt; 2] print(b) # [3, 4] 리스트 컴프리헨션을 사용하면 한 줄의 코드로 간결하게 새로운 리스트를 생성할 수 있습니다.</description>
    </item>
    
    <item>
      <title>AI Ops의 주역들</title>
      <link>https://happygrammer.github.io/dev/ai-ops-key-players/</link>
      <pubDate>Sat, 30 Mar 2024 23:53:06 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/ai-ops-key-players/</guid>
      <description>안녕하세요, 여러분. 오늘은 AI Ops에서 핵심적인 역할을 담당하는 전문가들에 대해 알아보겠습니다. AI Ops는 인공지능 시스템의 개발과 운영에 있어 다양한 분야의 전문가들 간의 긴밀한 협업이 필수불가결한 영역입니다.
먼저, 연구 과학자는 AI Ops에서 ML(Machine Learning) 분야의 발전을 이끄는 핵심 인력입니다. 이들은 새로운 알고리즘을 연구하고 개발함으로써 AI 기술의 혁신을 주도합니다. 최신 연구 동향을 파악하고, 실험을 통해 알고리즘의 성능을 검증하며, 학술 논문을 통해 연구 결과를 공유하는 것이 연구 과학자들의 주요 업무입니다. 다음은 TensorFlow를 사용하여 새로운 Neural Network 모델을 정의하는 예시 코드입니다.</description>
    </item>
    
    <item>
      <title>Git을 일관되게 사용하는 팁</title>
      <link>https://happygrammer.github.io/dev/git/git_convention/</link>
      <pubDate>Sat, 30 Mar 2024 23:45:09 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git_convention/</guid>
      <description>안녕하세요, 여러분! 오늘은 Git을 사용할 때 일관성을 유지하는 방법에 대해 이야기해 보려고 합니다. Git은 강력한 버전 관리 도구이지만, 팀원들 간의 사용 방식이 제각각이라면 혼란을 겪을 수 있습니다. 이런 문제를 해결하기 위해 몇 가지 팁을 공유하고자 합니다.
 Git 사용 규칙 만들기  팀원들과 함께 Git 사용 규칙을 정해 보세요. 예를 들어, 커밋 메시지 작성 방법, 브랜치 명명 규칙, 코드 리뷰 프로세스 등을 포함할 수 있습니다. 규칙을 문서화하여 모든 팀원이 쉽게 참조할 수 있도록 해 주세요.</description>
    </item>
    
    <item>
      <title>Git 저장소 히스토리 초기화하기</title>
      <link>https://happygrammer.github.io/dev/git/git-repository-reset/</link>
      <pubDate>Sat, 30 Mar 2024 23:20:00 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git-repository-reset/</guid>
      <description>안녕하세요, 여러분! 오늘은 Git 저장소의 히스토리를 초기화하는 방법에 대해 알아보도록 하겠습니다. 가끔 프로젝트를 진행하다 보면, 저장소의 커밋 히스토리를 초기화해야 할 때가 있죠. 그럴 때 아래 방법을 따라해 보시면 쉽게 해결할 수 있습니다.
먼저, 작업을 진행하는 로컬 컴퓨터에 Git이 설치되어 있는지 확인해 주세요. 터미널에서 아래 명령어를 입력하면 설치된 Git의 버전을 확인할 수 있습니다.
$ git --version git version 2.39.0 Git이 설치되어 있다면, 아래 단계를 따라 저장소 히스토리를 초기화해 봅시다.
 새로운 브랜치 생성  git checkout --orphan tmp_branch 명령어를 사용하여 tmp_branch라는 이름의 새 브랜치를 생성합니다.</description>
    </item>
    
    <item>
      <title>Git 브랜치 전략</title>
      <link>https://happygrammer.github.io/dev/git/git-branching-strategy/</link>
      <pubDate>Fri, 05 Jan 2024 00:59:29 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git-branching-strategy/</guid>
      <description>안녕하세요, 여러분. 오늘은 Git의 브랜치 전략에 대해 알아보겠습니다. 효과적인 브랜치 전략은 협업과 코드 관리에 있어 매우 중요합니다. 브랜치를 잘 활용하면 안정적이고 효율적인 개발 프로세스를 구축할 수 있습니다.
일반적으로 사용되는 브랜치 종류로는 dev 통합, qa 통합, master 통합, hotfix 브랜치가 있습니다. 각 브랜치의 역할과 관계를 이해하는 것이 중요합니다.
 dev 브랜치: 개발 작업이 진행되는 메인 브랜치입니다. 모든 새로운 기능 개발은 dev 브랜치에서 시작됩니다. qa 브랜치: 테스트를 위한 브랜치로, dev 브랜치의 부모 브랜치입니다.</description>
    </item>
    
    <item>
      <title>파이썬 예외 처리시 라인 번호 출력</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-exception-lineno/</link>
      <pubDate>Mon, 01 Jan 2024 22:33:29 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-exception-lineno/</guid>
      <description>파이썬에서 예외 처리를 할 때, 에러 메시지와 함께 해당 에러가 발생한 라인 번호를 출력하고 싶을 때가 있습니다. 이는 디버깅 과정에서 매우 유용할 수 있죠. 파이썬의 traceback 모듈을 사용하면 스택 추적 정보를 가져와서 예외가 발생한 파일 이름과 라인 번호를 확인할 수 있습니다. 아래 코드를 살펴봅시다.
import traceback try: # 예외 발생 가능한 코드 raise Exception(&amp;quot;예외 발생!&amp;quot;) except Exception as e: # 스택 추적 정보 가져오기 trace = traceback.format_exc() LOGGER.error(f&amp;quot;Failed to load dm.</description>
    </item>
    
    <item>
      <title>Mac에서 Kotlin 설치</title>
      <link>https://happygrammer.github.io/dev/language/kotlin/setup/</link>
      <pubDate>Mon, 09 Jan 2023 03:39:17 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/kotlin/setup/</guid>
      <description>kotlin은 IntelliJ IDEA 개발사로 유명한 JetBrains에서 2011년에 공개한 오픈 소스 프로그래밍 언어이다. Java와 유사하며 Java에 비해 조금 더 간결한 문법을 사용한다는 특징이 있다. Java와 100% 상호 호환이 가능하다. Android의 공식 언어로 채택된 언어이기도 하다. 코틀린 구성에 앞서 java를 설치하도록 한다. (환경 MacOS)
brew install openjdk@17 설치가 완료되면 설치된 openjdk 경로를 bash_profile에 반영해준다.
echo &#39;export PATH=&amp;quot;/usr/local/opt/openjdk@17/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; /Users/smarthome/.bash_profile source ~/.bash_profile 어어서 java버전을 확인한다.
$ java -version openjdk version &amp;quot;17.0.5&amp;quot; 2022-10-18 OpenJDK Runtime Environment Homebrew (build 17.</description>
    </item>
    
    <item>
      <title>딥러닝 GPU 성능 비교</title>
      <link>https://happygrammer.github.io/dev/gpu/</link>
      <pubDate>Wed, 21 Sep 2022 06:34:02 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/gpu/</guid>
      <description>GPU와 CPU의 차이점 GPU는 그래픽 처리에서 사용했다. 최근 GPU는 그래픽 처리 뿐 아니라 병렬 수치 연산에도 이용되고 있다. 딥러닝은 대량의 곱셈, 큰 행렬의 내적 등을 수행하는데 GPU 컴퓨팅을 이용하면 연속을 고속화하여 처리할 수 있다. CPU(CPU, Central Processing Unit)와 GPU(GPU, Grapical Processing Unit)는 공통적으로 마이크로프로세서이다. 둘다 데이터를 처리한다는 공통점이 있다. 그런데 이 둘은 아키텍처가 다르고 용도와 목적이 다르다. CPU는 코어 성능이 중요한 워크 로드에 적합하다. CPU 내부의 ALU(arithmetic Logic Unit)는 순차적인(sequential) 방식으로 명령어를 하나씩 처리하는 특징이 있다.</description>
    </item>
    
    <item>
      <title>클린 아키텍처 재해석</title>
      <link>https://happygrammer.github.io/dev/clean-architecture/</link>
      <pubDate>Mon, 13 Jun 2022 00:18:44 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/clean-architecture/</guid>
      <description>좋은 아키텍처란 시스템 생명 주기(개발, 유지보수, 배포, 운영)를 쉽게 지원할 수 있는 아키텍처이다.
 </description>
    </item>
    
    <item>
      <title>깃 저장소의 커밋 히스토리 초기화</title>
      <link>https://happygrammer.github.io/dev/initialize-git-repository/</link>
      <pubDate>Wed, 01 Dec 2021 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/initialize-git-repository/</guid>
      <description>깃 저장소를 마지막 변경 파일만 남기고 커밋 이력을 초기화하고 싶은 경우가 있다. 깃 저장소 커밋 이력을 초기화 하는 방법에 대해서 살펴보자. 작업 과정을 명확히 공유하기 위해 실재 입력한 명령어와 반영된 결과 그리고 실재 작업된 결과를 첨부 하였다. 다음과 같은 순서로 진행할 예정이다.
 원격 저장소의 파일을 지운다. 브랜치 작업을 이용한 커밋 히스토리 삭제 신규 파일 commit  파일을 삭제해 빈 저장소로 만들기 커밋 이력을 초기화하려면 temp 브랜치를 추가(추가한 temp 브랜치에는 커밋 히스토리가 없음)하고 커밋 히스토리가 있는 master 브랜치를 삭제한 후, temp 브랜치를 master 브랜치로 이름을 변경하는 것으로 가능하다.</description>
    </item>
    
    <item>
      <title>휴리스틱 가이드라인</title>
      <link>https://happygrammer.github.io/dev/heuristic/</link>
      <pubDate>Tue, 02 Nov 2021 23:37:11 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/heuristic/</guid>
      <description>휴리스틱 가이드라인은 직관적으로 판단할때 사용할 수 있는 UX적용 요소를 포함하고 있다. 웹에서 쓰이는 대표적인 휴리스틱 가이드라인으로는 제이콥 닐슨이 제시한 10가지 가이드라인이 있다.
1. 가시성 시스템은 사용자에게 시스템 상태를 적절한 시기에 인지하기 좋은 형태로 전달함
2. 익숙함 시스템은 사용자가 현실 세계에서 익숙한 단어를 사용함
3. 자유성 사용자가 실수로 특정 기능을 선택하더라도 복구할 수 있는 제어 방법을 제공함
4. 일관성 시스템에 사용하는 용어는 일관성 있게 사용
5. 예방 에러 예방을 위해 에러 메시지가 어떤 의미인지 사용자에게 전달</description>
    </item>
    
    <item>
      <title>알고리즘, 문제해결 기법</title>
      <link>https://happygrammer.github.io/dev/algorithm/why/</link>
      <pubDate>Thu, 16 Sep 2021 16:52:27 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/algorithm/why/</guid>
      <description>알고리즘을 공부하는 목적은 무엇일까? 알고리즘을 답습(踏襲)해 문제해결 기법을 훈련하는 것이다. 알고리즘을 자신의 언어로 풀어서 체계적으로 생각하는 훈련을 수 있을 것이다. 알고리즘은 귀납적 접근을 기반으로 한다.
귀납적인 접근 알고리즘 학습을 통해 귀납적 사고를 훈련할 수 있다. 귀납적(inductive)이라는 말은 본래 수학 분야에서 왔다. 귀납적이라는 말의 사전적 정의는 개별적인 특수한 사실이나 원리로부터 공통적을 추려내 일반적이고 보편적인 명제 및 법칙을 유도해 내는 일이다.
귀납적 사고는 도미노 효과와 비슷한 방식으로 작동한다. 첫번째 블럭이 넘어지면 두번째 블럭이 넘어지듯이, 전제가 성립하면 결론도 성립하게 된다.</description>
    </item>
    
    <item>
      <title>클로저란 무엇인가?</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/closures/</link>
      <pubDate>Sun, 01 Aug 2021 08:45:28 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/closures/</guid>
      <description>내부 함수와 외부 함수 자바스크립트는 기본적으로 함수 내부에 내부 함수 선언을 지원한다. 이렇게 내부에 함수를 중복해서 중첩(nested) 형태로 선언이 가능하며, 외부 함수는 내부 함수를 포함하는 형태로 선언이 가능하다.
function init() { // 외부 함수 function message() { // 내부 함수 return &amp;quot;happyg&amp;quot;; // lexical scope에 선언된 로컬 변수인 name 응답 가능 } return message(); } document.write(init()); // 외부에서는 내부 함수가 message인지 알 수 없다. 외부 함수인 init이 내부 함수인 message 를 포함한 선언 형태이다.</description>
    </item>
    
    <item>
      <title>아마존 웹 서비스 개요</title>
      <link>https://happygrammer.github.io/dev/cloud/amazon-web-service-overview/</link>
      <pubDate>Sat, 17 Jul 2021 15:11:42 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/amazon-web-service-overview/</guid>
      <description>AWS Ovewview  AWS 리전 한국에는 데이터 센터가 4개로 구성되어있고, 이를 가용 영역이라 부름(서울 리전인 경우) CDN(콘텐츠 전송 네트워크) cloud front 제공 AWS 이점 - 보안, 가용성, 성능, 확장성, 유연성  VPC(Virtual Private Computing)   사용자가 정의한 네트워크 공간 제공
  NAT Gateway는 내부 사설 IP(Private IP) 간의 Gate Way 역할., NAT Gateway에 EIP(Elastic IP)를 붙여서 외부 IP로 사용.
  InBound/OutBound
  Web Server는 443(port)에 대해 Any Open으로 제공</description>
    </item>
    
    <item>
      <title>장애 허용 시스템</title>
      <link>https://happygrammer.github.io/dev/cloud/distributed-system/fault-tolerance/</link>
      <pubDate>Wed, 19 May 2021 16:10:27 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/distributed-system/fault-tolerance/</guid>
      <description>분산 시스템이 있을때 하나의 노드에서 에러가 나더라도 전체 네트워크에 영향을 미쳐서는 안된다. 분산시스템을 구축하는 이유는 빠른 계산처리와 안전성을 도모하기 위해서이다. 빠른 계산 처리라 함은 하나의 컴퓨터로 처리할수 있는 계산량의 한계가 정해저 있어 병렬 처리를 하기 위함 이다. 안정성은 하나의 Node에 Fault가 나더라도 예비 Node가 있어 Node가 Fault가 되는것에 대해 대비해야 한다.
장애 허용 시스템 장애 허용 시스템(Fault Tolerance System)은 하나의 컴포넌트가 fault가 발생해도 시스템 운영에 영향을 주지 않도록 설계된 시스템이다. 다음과 같은 점을 고려할 수 있다.</description>
    </item>
    
    <item>
      <title>분산처리 시스템 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/distributed-system/about/</link>
      <pubDate>Tue, 18 May 2021 23:47:08 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/distributed-system/about/</guid>
      <description>분산처리 시스템은 여러 시스템 간의 동작을 일관성 있게 처리해 마치 하나의 프로세스가 하는 처리하는 것처럼 수행하는 시스템이다. 하나의 서버에 결집되어 있는 서버의 자원과 기능을 여러 서버에 분산 시켜 상호 협력함으로써 처리 성능과 신뢰성을 높이는 데 목적이 있다.
분산 시스템의 고전적인 문제 Failure Detection, Peer to Peer Systems, Key value store, sensor networks등이 으며, 동기화, 보안 관련 문제가 있다.
 동기화(Synchronization)은 실재 시간 근거로 싱크를 맞추는것이며, 분산 환경에서 싱크를 맞추는 것은 쉽지 않다.</description>
    </item>
    
    <item>
      <title>코드 리뷰 어떻게 할 것인가</title>
      <link>https://happygrammer.github.io/dev/code-review/</link>
      <pubDate>Fri, 09 Apr 2021 23:29:22 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/code-review/</guid>
      <description>코드리뷰는 코드 구조의 일관성과 안정성을 높이기 위해 진행하는 중요한 과정입니다. 코드리뷰를 통해 코드 스타일 준수, 잠재적 오류 예방, 성능 개선 등을 이룰 수 있죠.
코드리뷰 진행 시에는 팀 내 컨벤션을 기준으로 하되, 구글의 코드 스타일 가이드를 참고하는 것도 좋습니다. 구글은 다음과 같은 방식으로 코드리뷰를 진행해요.
 change list 준비 후 메일이나 gerrit 같은 코드리뷰 시스템으로 리뷰 신청 리뷰어가 코멘트를 남기는 방식으로 리뷰 진행 코드리뷰는 24시간 내 완료를 원칙으로 함 주요 로직은 unit test로 검증 실험적이거나 버려질 수 있는 코드는 속도 중시 불필요한 공백 제거 코멘트가 code quality 향상을 위한 것인지, 스타일 문제인지 구분  코드리뷰 문서는 누구나 이해할 수 있도록 다음 형식을 유지하는 게 좋아요.</description>
    </item>
    
    <item>
      <title>Sudo 권한 획득(CVE-2021-3156) 취약점 조치방법</title>
      <link>https://happygrammer.github.io/dev/linux/sudo/</link>
      <pubDate>Fri, 09 Apr 2021 21:45:33 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/sudo/</guid>
      <description>sudo 명령어의 -s 또는 -i 옵션을 사용할때 특수 문자 이스케이프시에 로컬 사용자가 root권한을 획득할 수 있는 보안 취약점이 발견 되었다.
 취약점 코드 - CVE-2021-3156 (취약점 명칭은 Baron Samedit라고 명명됨)  권한 없는 로컬 사용자가 인증 없이 root 권한 획득을 할 수 있다. 취약점이 있는 sudo 버전은 다음과 같다.
1.8.2 ~ 1.8.31p2 1.9.0 ~ 1.9.5p1 sudo 버전은 다음 명령어로 확인할 수 있다.
$ sudo -V sudo에 취약점이 있는지를 확인하고 싶다면 다음 명령어를 입력해 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>Git Workflow Diagram</title>
      <link>https://happygrammer.github.io/dev/git-workflow-diagram/</link>
      <pubDate>Sun, 21 Mar 2021 02:13:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git-workflow-diagram/</guid>
      <description>Git을 이용한 버전 관리는 S/W 개발 프로세스 중 하나가 되었습니다. 버전 관리를 이용하면 소스 코드 이력 관리를 통해 안정적인 소스 코드 관리 운용이 가능하지만 능숙한 사용까지 시간이 걸립니다. Git 사용을 돕기 위해 주요 Git 명렁어에 대한 다이어그램을 작성해 보았습니다. 보완이 필요한 점은 피드백 환영 합니다. 감사합니다.</description>
    </item>
    
    <item>
      <title>애자일 칸반과 스크럼</title>
      <link>https://happygrammer.github.io/dev/kanban-and-scrum/</link>
      <pubDate>Thu, 31 Dec 2020 11:00:24 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/kanban-and-scrum/</guid>
      <description>칸반과 스크럼의 차이 칸반과 스크럼은 프로젝트 목적 달성을 위해 사용하는 프로세스 도구이다. 스크럼은 럭비에서 차용된 것으로 스크럼은 세 명 이상의 선수가 공을 에워싸고 서로 어깨를 맞대어 버티는 공격 태세를 의미하는데, 팀워크를 강조하기 위한 용어다. 스크럼은 스프린트 기반의 점직적인 개발 방법론 이다. 칸반은 칸반이란 일본어로 카드나 눈에 보이는 기록이라는 것을 뜻한다. 적시생산시스템(Just in time)과 같이 순서가 정해진 공정에서 작업의 순서를 통제하는데 사용된다. 칸반과 스크럼의 차이는 다음과 같다.
    칸반 스크럼     규범 수 많다 적다   역할 구분 없음 Product Owner, Scrum Master, Team   작업 추가 가능 어려움   스프린트 스프린트 수행 여부는 팀이 결정 N번의 스프린트(2~4주) 진행   백로그 우선순위 백로그 우선순위를 고려하지 않음 백로그 우선순위를 고려함   일의 양 결정 X O - 스프린트 마다 일의 양이 결정됨    규범수와 역할 구분 관점에서 보면 이 둘 간의 차이를 알 수 있다.</description>
    </item>
    
    <item>
      <title>Linux 권한 관리</title>
      <link>https://happygrammer.github.io/dev/linux/permissions/</link>
      <pubDate>Wed, 30 Dec 2020 16:47:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/permissions/</guid>
      <description>현재 접속 사용자 현재 서버에 접속한 사용자의 id 확인은 users 명령어를 이용해 확인 한다.
$ users user users 명령과 비슷한 명령어로, 사용자의 접속 정보도 함께 볼 수 있는 명령어로 who 와 w 명령어가 있다.
who -H 명령어는 헤더 정보를 포함해 접속 사용자 정보를 표시한다.
$ who -H USER LINE WHEN user console Nov 27 07:09 user ttys000 Dec 8 23:25 user ttys001 Dec 9 19:27 user ttys003 Dec 14 03:35 가능한 많은 정보를 얻기 위해 -aH 옵션을 줄 수 있다.</description>
    </item>
    
    <item>
      <title>방화벽 설정 관리 iptables, firewalld</title>
      <link>https://happygrammer.github.io/dev/linux/iptables_firewalld/</link>
      <pubDate>Wed, 30 Dec 2020 16:47:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/iptables_firewalld/</guid>
      <description>Iptables 명령어를 이용한 방화벽 관리 Iptables 명령어는 Cent OS 6이하에서 사용하는 방화벽 설정 관리 명령이다.
방화벽 설정 확인 후 삭제 방화벽 설정 상태를 보려면 -L 옵션을 이용해 목록을 표시할 수 있다.
# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- anywhere anywhere tcp spt:40050 ACCEPT tcp -- anywhere anywhere tcp spt:40050 iptables -L 옵션을 주었을때 출력되는 prot 열은 프로토콜을 의미하며, 프로토콜의 종류로 tcp, udp, icmp, 또는 all가 있다.</description>
    </item>
    
    <item>
      <title>Linux 기본 관리 명령어</title>
      <link>https://happygrammer.github.io/dev/linux/commands-basic/</link>
      <pubDate>Wed, 30 Dec 2020 12:21:00 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/commands-basic/</guid>
      <description>앨리어스 사용 alias는 명령어를 대체하는 명령어이다. 명령어를 축약해 사용자의 정의 명령어를 정의할 수 있다. alias라고 입력하면 시스템이 정의한 alias 명령어를 확인할 수 있다.
$ alias 디렉터리만 조회하는 명령어는 다음과 같다.
$ ls -l | grep &amp;quot;^d&amp;quot; 용량이 큰 대상부터 출력하는 명령은 다음과 같다.
$ ls - al | sort -rk 5 # 5열(-k)을 기준으로 용량이 큰것 것(-r) 부터 출력 위 명령어는 lsd라는 앨리어스로 등록할 수 있다.
$ alias lsd=&#39;ls -l | grep &amp;quot;^&amp;quot;&#39; 아파치 서버를 시작하거나 종료하는 명령어를 앨리어스를 등록해 두면 편리하다.</description>
    </item>
    
    <item>
      <title>견고한 코드 설계의 원칙들</title>
      <link>https://happygrammer.github.io/dev/code-design/</link>
      <pubDate>Sat, 21 Nov 2020 09:09:47 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/code-design/</guid>
      <description>코드 설계의 기본 원칙  DRY (Don&#39;t Repeat Yourself)  한번 이상 동일하거나 유사한 코드를 작성하지 않는 것이 좋다.   SCP (Speaking Code Principle)  코드는 그 목적을 전달해야 한다. 코드에 주석을 추가했다는 것은 코드에 불충분한 목적이 있음을 암시 하기도 한다.   TDA (Tell, Don&#39;t Ask)  객체에게 정보를 요구하지 말고 그냥 행위하도록 시키라. (&#39;Law of Demeter&amp;rsquo;와 유사) 데이터 생성 객체(구현 정보 은닉, 캡슐화)로만 하고, 구체적인 타입이나 값은 넘기지 않는다.</description>
    </item>
    
    <item>
      <title>JAVA 멀티 스레드 프로그래밍</title>
      <link>https://happygrammer.github.io/dev/java/multithreading/</link>
      <pubDate>Sun, 18 Oct 2020 09:02:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/multithreading/</guid>
      <description>프로세스는 여러 명령어들의 하나의 실행 단위이다. 스레드는 하나의 프로세스에 존재하는 여러 개의 실행 단위이다. 하나의 스레드 실행은 싱글 스레드라 하며, 여러 스레드의 실행은 멀티 스레드라고 한다.
Thread Class 방식 vs Runnable 방식 thread class 방식은 Thread 클래스를 상속해 스레드를 실행하며, Runnable 방식은 Runnable 인터페이스를 구현해서 실행하는 방식이다.
1. Thread Class 방식 Thread 클래스를 상속해 스레드를 실행하는 예제이다.
class TestThreadByThreadClass extends Thread { public void run() { System.out.println(&amp;#34;스레드 실행중&amp;#34;); } public static void main(String args[]) { TestThreadByThreadClass thread = new TestThreadByThreadClass(); thread.</description>
    </item>
    
    <item>
      <title>맥 OS에서 아파치, PHP 시작 설정</title>
      <link>https://happygrammer.github.io/dev/installing-apache-php-on-macos/</link>
      <pubDate>Sat, 21 Mar 2020 21:15:12 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/installing-apache-php-on-macos/</guid>
      <description>퍼미션 문제가 발생할 수 있어 루트 사용자로 권한을 변경합니다.
sudo su - 맥 OS에서 아파치 시작 apachectl start http://localhost 접속해 서버 페이지 접속이 가능한지 확인합니다.
맥 OS에서 PHP 시작 서버 페이지가 표시 됐다면 서버 시작은 정상적으로 수행된 것 입니다. 서버가 정상적으로 정상적으로 시작 됐더라도 별도 설정을 하지 않으면 PHP 페이지는 출력되지 않습니다. PHP 페이지를 출력하려면 아파치 설정을 수정해야 합니다. 먼저 아파치 설정을 백업해 둡니다. 앞으로 설정이 바뀌더라도 디폴트 설정이 무엇인지 참고할 때 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>도커 컴포즈 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/docker-compose/</link>
      <pubDate>Sun, 01 Mar 2020 08:50:10 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/docker-compose/</guid>
      <description>도커 컴포즈는 여러 컨테이너들의 상태를 관리하는 도구입니다. 일반적으로 도커에서 관리하는 컨테이너 상태는 다음과 같습니다.
 created, restarting, running, removing, paused, exited, dead  이중 도커 컴포즈가 관리하는 상태는 다음과 같습니다. 도커 컴포즈는 도커 데스크탑 for MAC 설치시 이미 포함되어 있어 별도 설치를 하지 않아도 됩니다.
도커 컴포즈 실행 도커 컴포즈는 여러 컨테이너의 실행을 docker-compose.yml 파일을 docker-compose up 명령어로 실행할 수 있게 합니다.
docker-compose 파일에 서비스 정의 docker-compose.yml는 서비스를 정의하는 파일입니다. 도커 컴포즈에 정의한 서비스는 web과 redis입니다.</description>
    </item>
    
    <item>
      <title>도커에 Mariadb 설치</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/mariadb/</link>
      <pubDate>Sun, 01 Mar 2020 00:55:12 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/mariadb/</guid>
      <description>도커 실행 여부 체크 설치를 진행하기 전에 도커 실행 여부를 확인합니다. 도커가 실행중인 상태가 아니면 다음과 같은 예외 메시지가 출력됩니다.
Using default tag: latest Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 지금 부터 mariadb를 다운로드 받아 설정 까지 진행하도록 하겠습니다.
도커 이미지 다운로드 docker pull mariadb 컨테이너 실행 3306 port로 설정해 실행합니다.
docker container run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 --name mariadb mariadb docker 볼륨을 /Users/Shared/data/mariadb로 설정합니다.</description>
    </item>
    
    <item>
      <title>Angular CLI 설치와 프로젝트 설정</title>
      <link>https://happygrammer.github.io/dev/frontend/angular/angular-cli/</link>
      <pubDate>Sat, 29 Feb 2020 18:15:02 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/angular/angular-cli/</guid>
      <description>Angular는 Angular CLI를 이용해 프로젝트 관리의 복잡도를 낮추고 Angular 개발에만 집중할 수 있게 합니다.
Angular CLI 소개와 설치 지금 소개하려는 Angular CLI(Angular Command Line Interface)는 개발자가 Angular 개발에 만 집중할 수 있도록 개발에 필요한 Angular 프로젝트의 설정이나 프로젝트의 전반적인 관리를 명령어 기반으로 수행할 수 있게 지원합니다. Angular CLI가 제공하는 기능은 다음과 같습니다.
■ Angular 프로젝트 생성
■ Angular의 중요 구성요소 추가(컴포넌트, 지시자, 파이프, 서비스)
■ 코드 변경 시 빌드를 수행하고 애플리케이션을 재시작</description>
    </item>
    
    <item>
      <title>crontab을 이용한 스케쥴 관리</title>
      <link>https://happygrammer.github.io/dev/linux/shell/crontab/</link>
      <pubDate>Fri, 28 Feb 2020 10:39:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/crontab/</guid>
      <description>crontab 설정 # ┌───────────── min (0 - 59) # │ ┌────────────── hour (0 - 23) # │ │ ┌─────────────── day of month (1 - 31) # │ │ │ ┌──────────────── month (1 - 12) # │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6는 일~토, 7=일) # │ │ │ │ │ # │ │ │ │ │ # * * * * * &amp;lt;실행할 커맨드&amp;gt; crontab 작업 리스트 $ crontab -l crontab 로그 확인 $ cat /var/log/cron crontab 설정 확인 $ cat /var/spool/cron/&amp;lt;user_id&amp;gt; crontab service 상태 확인과 재실행 $ service crond status crond (pid 2994)를 실행하고 있습니다.</description>
    </item>
    
    <item>
      <title>Docker 명령어 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/docker/</link>
      <pubDate>Wed, 19 Feb 2020 06:50:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/docker/</guid>
      <description>기본적인 명령어 컨테이너 확인 docker container ls $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2463b80300ec mariadb &amp;quot;docker-entrypoint.s…&amp;quot; 13 seconds ago Up 12 seconds 0.0.0.0:3306-&amp;gt;3306/tcp mariadb  컨테이너 목록을 표시하는 명령어인 docker ps 는 오래전 방식입니다. 새로운 명령어 형식은 docker container &amp;lt;subcommand&amp;gt;입니다. 즉, docker container ls를 권장합니다. 이때 docker container ls는 docker container ps와 동일한 명령어입니다. 즉 아래 4개 명령어는 정확히 동일 기능을 수행하는 명령어입니다.  실행중인 컨테이너 정보를 표시하는 동일 명령어</description>
    </item>
    
    <item>
      <title>MAC 단축키 가이드</title>
      <link>https://happygrammer.github.io/dev/mac/</link>
      <pubDate>Sun, 19 Jan 2020 12:55:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/mac/</guid>
      <description>본 문서는 MAC 단축키를 소개하는 단축키 가이드입니다. 맥 OS를 이용하면서 가장 자주 이용할만한 단축키를 선별해서 소개하는데 목적이 있습니다.
조합키 기호 맥에서 다른 키와 조합시 사용하는 조합키 기호입니다.
command ⌘ shift ⇧ option ⌥ control ⌃
단축키 목록 for MAC    단축키 조합 설명     ⌘ + H 현재 창을 숨김   ⌘ + F3 모든 창을 숨김   ⌘ + TAB 창 사이 이동   ⌘ + W 창 닫기 (⌥옵션 추가하면 전체 창 닫기)   ^ + 방향키 열린창 이동   ⌘ + 번호키 크롬, 사파리 브라우저 사용시 해당 번호에 해당하는 탭으로 이동   ^ + ⇧ + TAB 현재창 종료   ⌘+⌥+I 크롬 소스코드 보기   ⌘+⌥+ESC 프로세스 강제 종료창 띄우기   ⌘ + ` | 현재 프로그램 창 내에서 창전환 |    ⌘+⌥+L 다운로드 폴더 열기   ⌘+⌥+D 독바 숨기기, 보이기    시스템 관리 메뉴 for MAC    맥 이름 윈도우 대응 역할     할성 상태 보기 작업 관리자 프로세스별 CPU, 메모리, 에너지, 디스크, 네트워크 사용율 보기                   VSCode for MAC    맥 이름 윈도우 대응 역할     ⌘⇧F ALT+SHIFT+F 프로세스별 CPU, 메모리, 에너지, 디스크, 네트워크 사용율 보기                   </description>
    </item>
    
    <item>
      <title>클린코드를 위한 중요 원칙 5가지</title>
      <link>https://happygrammer.github.io/dev/clean-code/</link>
      <pubDate>Thu, 16 Jan 2020 01:17:18 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/clean-code/</guid>
      <description>클린코드를 위한 중요 원칙 5가지가지가 무엇인지에 대해 살펴 보고자 한다.
1. 네이밍 컨벤션 준수 구글의 자바 가이드 와 같은 사례를 참조 하면 좋다. 관례적으로 네이밍 컨벤션은 다음과 같은 원칙을 따르는 것이 좋다.
 클래스명은 명사를 사용하며 의미가 드러나는 이름을 짓는다. 변수는 의도가 드러나는 작성한다. 메서드는 객체의 동작을 의미하므로 동사를 사용하여 이름을 짓는다. 멤버 벼수, 인자명, 로컬 변수명은 lowerCamelCase 방식을 따른다. 상수 변수명은 CONTANT_CASE 방식을 이용한다.  // Constants static final int NUMBER = 5; static final ImmutableList NAMES = ImmutableList.</description>
    </item>
    
    <item>
      <title>날짜와 시간 처리</title>
      <link>https://happygrammer.github.io/dev/linux/shell/date-time/</link>
      <pubDate>Wed, 15 Jan 2020 07:15:14 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/date-time/</guid>
      <description>시간 설정 $ date -s &amp;quot;2020-02-02 04:00:20&amp;quot; 날짜 포맷 출력(기본 포맷) mm/dd/yy형식으로 날짜 출력
date +&amp;quot;%D&amp;quot; 날짜 포맷 출력(지정 포맷) yyyy-mm-dd 형식의 날짜 출력
date &amp;quot;+%Y-%m-%d&amp;quot; echo date # 2020-01-14 시간 출력(기본 포맷) hh-mm-ss 형식의 시간 출력
date +&amp;quot;%T&amp;quot; # 04:09:51 시간 출력(12시간 기준) date +&amp;quot;%r&amp;quot; # 04:09:51 AM 날짜와 시간 출력(기본 포맷) now=$(date) echo $no # 2020년 1월 15일 수요일 05시 19분 36초 MSK 날짜와 시간 출력(지정 포맷) yyyy-mm-dd_hh-mm-ss 형식으로 출력</description>
    </item>
    
    <item>
      <title>[쉘스크립트] 텍스트 처리를 위한 쉘 명령어</title>
      <link>https://happygrammer.github.io/dev/linux/shell/text/</link>
      <pubDate>Wed, 15 Jan 2020 06:38:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/text/</guid>
      <description>본 문서는 실무를 하면서 자주 쓰는 리눅스 쉘 명령어 소개하기 위한 목적이 있습니다.
cat 명령어 cat 명령어는 concatenate의 줄임말입니다. 리눅스에서 빈번하게 사용하는 파일 보기 명령어입니다.
기본 문법으로 파일 내용 출력가 있습니다.
$ cat &amp;lt;file-name&amp;gt; 파일 내용을 출력해 특정 파일명으로 저장 할 수 있습니다.
$ cat &amp;lt;file-name&amp;gt; &amp;gt; &amp;lt;output-file-name&amp;gt; 여러 파일 출력이 가능합니다.
cat sample1.txt sample2.txt &amp;gt; sample3.txt 파일 내용 출력시 -n 옵션을 추가하면 줄번호 표시가 가능합니다.
cat -n &amp;lt;file-name&amp;gt; grep 명령어와 조합해서 무자열 필터에 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>1시간 안에 펄(Perl) 언어 익히기</title>
      <link>https://happygrammer.github.io/dev/perl/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/perl/</guid>
      <description>본 포스팅에서 사용한 예제는 다운로드 가능하다. Perl은 고수준의 동적 타입 언어로 csh, Pascal, BASIC-PLUS, PHP, Python 등과 비교되는 언어다. Perl은 쉘 스크립트로 기원했기에 다른 스크립트나 다른 프로그램을 엮어 주는 글루 코드(glue code) 언어로 시스템 관리에도 적합한 언어이다. C, sed, awk 그리고 sh와 같은 언어나 프로그램들의 가장 좋은 점들을 취합한 언어이기도 하다. sed, awk, sh를 사용하여 문제를 풀기 어렵다면 Perl이 대안이 된다. 이외에도 다음과 같은 특징이 있다.
 거의 모든 운영체제에 설치되어 있다.</description>
    </item>
    
    <item>
      <title>파이썬 3 배열과 딕셔너리</title>
      <link>https://happygrammer.github.io/dev/language/python3/python3/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python3/</guid>
      <description>배열 배열 탐색 token = [s.split() for s in arr] # 공백 단위로 split token = [s.split()[1:] for s in arr] # 공백 단위로 split 딕셔너리 딕셔너리 선언 #!/usr/bin/python3 dict = {&#39;Name&#39;: &#39;Sunflower&#39;, &#39;Kingdom&#39;: &amp;quot;Plantae&amp;quot;, &#39;Class&#39;: &#39;Magnoliopsida&#39;} print (&amp;quot;dict[&#39;Name&#39;]: &amp;quot;, dict[&#39;Name&#39;]) print (&amp;quot;dict[&#39;Kingdom&#39;]: &amp;quot;, dict[&#39;Kingdom&#39;]) print (&amp;quot;dict[&#39;Class&#39;]: &amp;quot;, dict[&#39;Class&#39;]) 딕셔너리 keys 사용 for key in dict.keys(): print(key+&amp;quot;:&amp;quot;+dict[key]) 딕셔너리 메소드    Sr.No. Method &amp;amp; Description     1 dict.</description>
    </item>
    
    <item>
      <title>ProcessBuilder 클래스 - 운영체제 프로세스 생성</title>
      <link>https://happygrammer.github.io/dev/java/processbuilder/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:19 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/processbuilder/</guid>
      <description>이전 버전에서는 Runtime.exec()을 이용해 프로세스를 실행할 수 있습니다. 그런데 이 방법은 When Runtime.exec() won&#39;t에서도 소개 됐듯이 표준 입력과 출력에 대한 제한된 버퍼 사이즈로 인해 하위 프로세스가 block 되거나 데드락이 되기도 하는 문제가 있었습니다.
자바 JDK 7 이상에서는 이러한 문제점을 해결 하고자 Proccess Builder 클래스가 소개됩니다. 이 클래스는 운영체제 프로세스 생성할 때 사용합니다. Process Builder 클래스 인스턴스에는 프로세스를 제어할 때 필요한 유용한 속성을 제어합니다. 예를 들어 start() 메서드는 입력 받은 커맨드를 실행해 새로운 프로세스를 생성 합니다.</description>
    </item>
    
    <item>
      <title>Hugo 정적 사이트 생성기 가이드</title>
      <link>https://happygrammer.github.io/dev/hugo/</link>
      <pubDate>Wed, 15 Jan 2020 06:27:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/hugo/</guid>
      <description>Hugo는 Go언어로 만들어진 정적 사이트 생성기(static site generator)입니다. Go언어로 만들어져서 정적 파일 생성이 빠르고 최근 많은 인기를 얻고 있습니다.
변수 사전 정의 변수
 {{ .Title }} 사용자 정의
{{ $address }} 템플릿 가져 오기 파셜 템플릿 가져오기
{{ partial &amp;quot;header.html&amp;quot;}} 템플릿 룩업 순서 layouts/posts/single.html.html가 layouts/posts/single.html보다 우선 순위가 높습니다.
베이스 템플릿 layouts/_default
위 디렉터리에 접근해보면 베이스 템플릿인 baseof.html가 존재합니다. 디폴트 리스트 템플릿인 list.html 파일이 존재합니다.
템플릿 템플릿 설치는 https://themes.gohugo.io/ 사이트를 이용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>1시간 안에 Git 익히기</title>
      <link>https://happygrammer.github.io/dev/git/</link>
      <pubDate>Mon, 06 Jan 2020 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/</guid>
      <description>Git은 분산 버전 관리 시스템으로 리눅스 토발즈가 만들었으며 파일의 변경사항을 추적하고 관리할 수 있습니다.
1. Git 설치  GIt 설치 : https://git-scm.com/downloads Github : 깃허브는 Git을 지원하는 웹 호스팅 서비스 Github Desktop : https://desktop.github.com/, Github을 편리하게 이용할 수 있도록 만든 소프트웨어  2. Git을 이용한 형상 관리 http://nvie.com/posts/a-successful-git-branching-model/
3. Git 쉘 명령어 기본 명령어  git init: 깃 저장소를 초기화한다. git help: 깃 명령어를 확인한다. git status: 저장소 상태 정보 표시(저장소에 존재하는 파일, 커밋이 필요한 변경 사항, 현재 브랜치 위치 등)  상태 상태라면 &amp;quot;your branch is up-to-date with &#39;origin/master&#39;&amp;quot;와 같이 표시    사용자 설정  git config &amp;ndash;global user.</description>
    </item>
    
    <item>
      <title>1시간 안에 Vi 익히기</title>
      <link>https://happygrammer.github.io/dev/vi/</link>
      <pubDate>Mon, 06 Jan 2020 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/vi/</guid>
      <description>vi 에디터는 유닉스 에디터다. 터미널에서 쉘이나 각종 txt 파일, 스크립트를 수정할때 종종 사용한다. 단축키를 알아 두면 터미널 작업시 도움이 된다. 많은 명령어가 있지만 본 포스팅은 자주 쓰는 명령어만 추가해 두었다.
실행  view filename : 읽기전용으로 vi filename : 에디팅모드로 파일을 연다.  커서이동   ^ : 문장 시작으로 (또는 0)
  $ 문장 끝으로
  gg : 문서 시작으로
  :$ 문서 끝으로
  :숫자 해당 라인으로</description>
    </item>
    
    <item>
      <title>ICONV 인코딩 형식 변환</title>
      <link>https://happygrammer.github.io/dev/linux/iconv/</link>
      <pubDate>Wed, 01 Jan 2020 17:53:20 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/iconv/</guid>
      <description>iconv 명령어는 입력 파일의 인코딩을 지정한 인코딩으로 변경할 수 있는 명령어(/usr/bin/iconv)이다.
EUC KR을 UTF 8로 변경 iconv 명령어에 -c 옵션을 이용해 컨버팅이 되지 않는 문자열은 무시 하도록 할수 있다. 아래 명령어는 euc-kr에서 utf-8로 변경하는 명령이다.
iconv -c -f euc-kr -t utf-8 FILE_EUCKR.txt &amp;gt; FILE_UTF8.txt UTF-8을 EUC-KR로 변경 iconv -c -f utf-8 -t euc-kr FILE_UTF8.txt &amp;gt; FILE_EUCKR.txt ICONV 옵션    옵션 설명     -c 변환할 수 없는 문자는 버림   -f ENCODING, &amp;ndash;from-code=ENCODING 입력 파일의 인코딩   -t ENCODING, &amp;ndash;to-code=ENCODING 출력 파일의 인코딩   &amp;ndash;list, -l 지원하는 인코딩 목록들을 출력   &amp;ndash;output, -o file 변환 내용을 터미널 추력 대신 지정한 파일로 출력   &amp;ndash;silent, -s 경고 메시지를 출력하지 않음   &amp;ndash;verbose 자세한 상태 정보를 출력    ICONV &amp;ndash;help 옵션 상세 내용 $ iconv --help Usage: iconv [OPTION.</description>
    </item>
    
    <item>
      <title>@Controller와 @RestController 어노테이션</title>
      <link>https://happygrammer.github.io/dev/backend/spring/mvc-restful/</link>
      <pubDate>Wed, 20 Nov 2019 06:37:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/backend/spring/mvc-restful/</guid>
      <description>@Controller 어노테이션을 이용한 MVC 패턴 MVC는 @Controller에 기반해 작동하는 View 기반의 기술이며, REST는 @RestController 어노테이션을 이용해 객체 데이터 응답 기술입니다. 아래 그림은 전통적인 MVC 패턴 방식의 처리 과정을 보여주고 있습니다.
스프링은 사용자 요청에 대해 Dispatcher Servlet는 최종 처리 결과로 View를 Return해줍니다. DispatchServlet은 아래 각 하위 요소들을 호출함으로서 클라이언트에 최종 http 응답을 만듭니다. URI가 입력되는 Handler mapping을 이용해 컨트롤러로 연결해 줍니다. 컨트롤러에서는 MovelAndView 객체를 View Resolver로 반환합니다. View Resolver는 ModelAndView 객체를 이용해 View를 생성합니다.</description>
    </item>
    
    <item>
      <title>Spring Boot 시작하기</title>
      <link>https://happygrammer.github.io/dev/backend/spring/spring-boot/</link>
      <pubDate>Wed, 20 Nov 2019 06:37:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/backend/spring/spring-boot/</guid>
      <description>스프링 부트는 쉽게 제품 등급의 독립형 스프링 기반 애플리케이션을 만들 수 있습니다. 대부분의 스프링 부트 애플리케케이션은 적은 설정을 필요로 합니다.
특징  독립형 애플리케이셩 생성 내장 톰캣, 제티 포함. (WAR파일 배포 불필요) 스타터는 단순한 빌드 설정을 이용합니다. Spring 및 타사 의존 라이브러리를 자동으로 설정 되도록 합니다. 운영에 필요한 health 체크, 외부 설정 등의 기능을 제공합니다. 코드를 생성하거나 XML 설정을 요구 하지 않습니다.  스프링 부트 소개 이 문서는 레퍼런스 문서의 번역 문서입니다.</description>
    </item>
    
    <item>
      <title>디자인패턴 적용 Guide</title>
      <link>https://happygrammer.github.io/dev/design-pattern/</link>
      <pubDate>Sat, 02 Jun 2018 23:32:10 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/design-pattern/</guid>
      <description>디자인 패턴이란 특정 컨텍스트 내에서 주어진 문제에 대한 해결책이다. 어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받을 수 있는 문제에 봉착했다면, 그 제약조건 내에서 목적을 달성하기 위한 해결책을 찾아낼 수 있는 디자인을 적용한다. 디자인 패턴의 과다한 사용은 불필요하게 복잡한 코드를 초래할 수 있다. 항상 가장 간단한 해결책으로 목적을 달성할 수 있도록 하고, 반드시 필요할 때만 디자인 패턴을 적용하자. 코딩할 때 어떤 패턴을 사용하고 있는지 주석으로 적어주자. 클래스와 메서드 이름을 만들 때도 사용 중인 패턴이 분명하게 드러날 수 있도록 해보자.</description>
    </item>
    
    <item>
      <title>Use_strict</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/use_strict/</link>
      <pubDate>Fri, 28 Nov 2014 08:17:03 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/use_strict/</guid>
      <description>use strict 키워드는 ECMAScript 언어 사양(5번째 버전)에 포함되어 있다. ECMA스크립트는 ECMA-262에 의해 표준화된 언어의 이름이다. 자바스크립트와 J스크립트는 모두 ECMA스크립트와의 호환을 목표로 하면서, ECMA 규격에 포함되지 않는 확장 기능을 제공한다. 자바스크립트 라이브러리를 보다보면 strict mode 키워드를 만나볼 수 있다. strict mode는 자바스크립트를 좀더 엄격하게 다루고자 하는 의미이다.
Strict Mode를 사용하는 두가지 이유   모듈화 작업시 모호한 변수선언에 대해 제한과 엄격한 규칙을 통한 오류 발생 가능성을 낮춘다.
  전역변수와 지역변수간 Scope에 따른 변수 충돌을 방지할 수 있다.</description>
    </item>
    
  </channel>
</rss>