<!DOCTYPE html>
<html>
<head>
    <title>해피그의 코드랩</title>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="해피그의 코드랩" />
    
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://happygrammer.github.io/" />
    
    <meta property="og:image" content="https://happygrammer.github.io/thumnail.jpg" />
    <meta name="twitter:image" content="https://happygrammer.github.io/thumnail.jpg" />

    <script src="https://happygrammer.github.io/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<link href="https://happygrammer.github.io/index.xml" rel="alternate" type="application/rss+xml" title="해피그의 코드랩" />
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="https://happygrammer.github.io/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://happygrammer.github.io/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://happygrammer.github.io/css/style.css">
    
    <meta name="generator" content="Hugo 0.62.0" />
</head>

<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://happygrammer.github.io/">해피그</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">About</a>
                
                <a class="main-nav-link" href="/ai">AI</a>
                
                <a class="main-nav-link" href="/dev">Dev</a>
                
                <a class="main-nav-link" href="/insights">Insights</a>
                
                <a class="main-nav-link" href="/mlops">MLOps</a>
                
                <a class="main-nav-link" href="/nlp">NLP</a>
                
                <a class="main-nav-link" href="/rust">Rust</a>
                
		</nav>
            <nav id="sub-nav">
		<div id="search-form-wrap"></div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/insights/coding-concisely/">간결하게 코딩하기</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/insights/coding-concisely/" class="article-date">
                        <time datetime='2022-09-09T22:01:15.000&#43;09:00' itemprop="datePublished">2022-09-09</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    코드를 작성할때 간결함이란 그저 짧게만 작성한 코드를 의미하지 않는다. 꼭 필요한 코드를 충분히 잘 작성하여 목적에 맞는 기능이 동작해야 한다. 코드 작성 시의 간결함은 그저 잘 동작하는 코드만을 작성하는 것을 의미하지는 않는다. 불필요한 코드 작성을 제거하여 목적지가 분명한 방향성을 포함한다.
간결한 코드는 경험에서 나온다. 가볍고 간결한 코드는 정확한 이해 없이 그저 짧게 작성한 코드를 의미한다. 깊이있고 간결한 코드는 관련 지식을 바탕으로 간단명료하게 작성된 코드를 의미한다. 간결한 코드를 잘 작성하기 위해 코드를 깊숙이 파고들어가 분석하고 이해해야 한다.
                    </p>
                    <p class="article-more-link">
                        <a href="/insights/coding-concisely/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/insights/find-out-the-bad-code/">못난 코드 알아보기</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/insights/find-out-the-bad-code/" class="article-date">
                        <time datetime='2022-09-08T13:33:15.000&#43;09:00' itemprop="datePublished">2022-09-08</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    훌륭한 코드를 작성하고 싶다면 코드를 잘 쓰려고 노력하는데 그치지 말고 잘못 작성된 코드를 알아보는 감각을 키우는 노력이 필요하다. 바이올린과 같은 현악기는 연주자가 줄을 팅겨 보면서 음높이를 조절한다. 음높이를 조절할때는 음감을 이용하여 조율한다. 악보를 외우고 숙달하면 숙달된 바이올리니스트의 시늉을 하면서 한두 곡 정도는 연주가 가능할 수 있지만 모든 연주를 그렇게 할수는 없다. 올바른 코드를 작성하려면 잘못 작성된 코드를 먼저 알아보는 감각이 필요하다.
어떻게 하면 못난 코드를 알아볼까? 쉽고 간단한 방법이 있다. 셀프 코드 리뷰를 진행해 보는 것이다.
                    </p>
                    <p class="article-more-link">
                        <a href="/insights/find-out-the-bad-code/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/dev/clean-architecture/">클린 아키텍처 재해석</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/dev/clean-architecture/" class="article-date">
                        <time datetime='2022-06-13T00:18:44.000&#43;09:00' itemprop="datePublished">2022-06-13</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    좋은 아키텍처란 시스템 생명 주기(개발, 유지보수, 배포, 운영)를 쉽게 지원할 수 있는 아키텍처이다.
 
                    </p>
                    <p class="article-more-link">
                        <a href="/dev/clean-architecture/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/dev/initialize-git-repository/">깃 저장소의 커밋 히스토리 초기화</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/dev/initialize-git-repository/" class="article-date">
                        <time datetime='2021-12-01T01:26:13.000&#43;03:00' itemprop="datePublished">2021-12-01</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    깃 저장소를 마지막 변경 파일만 남기고 커밋 이력을 초기화하고 싶은 경우가 있다. 깃 저장소 커밋 이력을 초기화 하는 방법에 대해서 살펴보자. 작업 과정을 명확히 공유하기 위해 실재 입력한 명령어와 반영된 결과 그리고 실재 작업된 결과를 첨부 하였다. 다음과 같은 순서로 진행할 예정이다.
 원격 저장소의 파일을 지운다. 브랜치 작업을 이용한 커밋 히스토리 삭제 신규 파일 commit  파일을 삭제해 빈 저장소로 만들기 커밋 이력을 초기화하려면 temp 브랜치를 추가(추가한 temp 브랜치에는 커밋 히스토리가 없음)하고 커밋 히스토리가 있는 master 브랜치를 삭제한 후, temp 브랜치를 master 브랜치로 이름을 변경하는 것으로 가능하다.
                    </p>
                    <p class="article-more-link">
                        <a href="/dev/initialize-git-repository/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/insights/break_the_rules/">아인슈타인의 문제 해결법</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/insights/break_the_rules/" class="article-date">
                        <time datetime='2021-11-24T22:14:45.000&#43;09:00' itemprop="datePublished">2021-11-24</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    필자는 아인슈타인에 대해 관심이 많다. 인류가 알지 못했던 물리학의 비밀을 밝혀준 천재여서 이기도 하지만, 그의 인생 철학들이 많이 공감되고, 필자가 추구하는 방향이기도 하다.
같은 일을 반복하면서 다른 결과가 나오기를 기대하는 것보다더 확실한 정신병 증세는 없다. 아인슈타인은 무한한 상상력으로 자유로운 사고가 가능했다. 그의 자유로운 사고의 원천은 순응하지 않는 태도였다.
나는 학습을 방해하는 유일한 훼방꾼은 나의 교육이다. 교육을 받고 자란 우리들은 사회화 과정을 겪어 법칙에 복종하도록 교육을 받았다. 교육은 권위에 복종하는 것 가르친다.
                    </p>
                    <p class="article-more-link">
                        <a href="/insights/break_the_rules/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/nlp/t5/">T5 모델 소개 및 실습</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/nlp/t5/" class="article-date">
                        <time datetime='2021-11-21T20:19:26.000&#43;09:00' itemprop="datePublished">2021-11-21</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    사전 훈련된 모델이 다운스트림 태스크로의 전이학습은 자연어처리의 강력한 기술로 부상했다. 전이학습 모델 중 T5모델에 살펴보고자 한다.
T5 모델 소개 T5[1]는 모든 텍스트 기반 언어 문제를 텍스트 대 텍스트 형식으로 변환하는 통합 프레임워크(unified framework)를 도입했다. 이 연구는 C4(Colossal Clean Crawled Corpus) 코퍼스를 결합하여, 요약, 질의응답, 분류 및 기타 문제에 대해서 최신 SOTA(state-of-the-art)를 달성했다.
사전 훈련된 모델이 다운스트림 태스크로의 전이학습은 자연어처리의 강력한 기술로 부상했다. T5는 모든 텍스트 기반 언어 문제를 텍스트 대 텍스트 형식으로 변환하는 통합 프레임워크(unified framework)를 도입했다.
                    </p>
                    <p class="article-more-link">
                        <a href="/nlp/t5/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/nlp/word2vec/">Word2vec를 이용한 임베딩</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/nlp/word2vec/" class="article-date">
                        <time datetime='2021-11-21T20:19:26.000&#43;09:00' itemprop="datePublished">2021-11-21</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    Word2vec은 워드 고품질의 워드 벡터를 생성하는 임베딩 태스크에 사용할 수 있는 모델입니다. 구글의 Tomas Mikolov이 2013년에 논문으로 발표했습니다. 이 논문에서 소개하는 단어 예측 모델로 크게 CBOW와 Skip-gram을 소개합니다. CBOW는 Context 정보를 활용해 현재 단어를 예측 하는 모델이라면 Skip-gram은 현재 워드 주변의 단어를 예측하는 모델입니다. Word2vec을 실행하면 입력으로 대규모 텍스트 코퍼스를 수백 차원의 벡터 스페이스(vector space)로 만듭니다. 기존 LSA(latent semantic analysis)에 비해 여러 장점이 있습니다.
 계산 비용이 적습니다. 정확도(accuracy)가 개선 됐습니다.
                    </p>
                    <p class="article-more-link">
                        <a href="/nlp/word2vec/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/nlp/sub-words-model/">서브워드 모델</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/nlp/sub-words-model/" class="article-date">
                        <time datetime='2021-11-21T20:19:26.000&#43;09:00' itemprop="datePublished">2021-11-21</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    서브워드 알고리즘 서브워드와 관련한 유명한 알고리즘은 다음 네가지가 있습니다.
 Byte Pair Encoding (BPE) WordPiece Unigram Language Model SentencePiece  BPE BPE(Byte Pair Encoding)는 서브 워드 사전 구축에 사용되는 알고리즘은 다음 그림과 같습니다.
WordPiece 워드 피스(WordPiece)는 일본어와 한국어의 음성 문제를 해결 하기 위해 나온 모델입니다.(2012년) 워드 피스는 BPE와 유사하며 차이점은 새로운 서브 워드를 만들 수 있다는 점입니다.
Unigram 모델 쿠도 연구자가 소개한 모델입니다. 이 모델이 가정 하는 것은 모든 서브워드는 독립적인 이며 서브 워드 시퀀스이 나타날 확률은 서브 워드 확률에 결정된다는 점입니다.
                    </p>
                    <p class="article-more-link">
                        <a href="/nlp/sub-words-model/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/nlp/srl/">시맨틱 롤 레이블링 소개</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/nlp/srl/" class="article-date">
                        <time datetime='2021-11-21T20:19:26.000&#43;09:00' itemprop="datePublished">2021-11-21</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    시맨틱 롤 레이블링은 NLP 처리의 과정 중 하나이다. 시맨틱 롤 레이블링은 다른 말로 shallow semantic parsing, slot-filling, 의미역 결정과 같은 말로도 불린다. NLU를 하기 전의 가장 기본적인 접근은 형태소 분석과 구문 분석이다. 기본적인 처리가 끝나면 시맨틱 롤 레이블을 수행할 수 있다.
시맨틱 롤 레이블링 역사 SRL은 필모어(Charles J. Fillmore) 연구자에 의해 제안된 방법이다. 초창기 연구에서는 predicate에 해당하는 역할을 찾으려는 시도들이 있었다. 이후 프레임 넷을 이용한 SRL이라는 방식으로 확장이 되었다.
시맨틱 롤의 종류 시맨틱 롤(role)이라는 것은 우리 말로 의미역(semantic role)이라고 볼 수 있다.
                    </p>
                    <p class="article-more-link">
                        <a href="/nlp/srl/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/nlp/text-preprocessing/">텍스트 전처리</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/nlp/text-preprocessing/" class="article-date">
                        <time datetime='2021-11-21T20:19:26.000&#43;09:00' itemprop="datePublished">2021-11-21</time>
                    </a>
                    
                    
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    텍스트 전처리(text preprocessing)은 입력 데이터셋에 섞여 있는 불필요한 노이즈를 제거하거나 데이터를 일관성있게 만드는 정규화 과정을 포함한다. 전처리는 크게 두 단계의 작업을 수행한다.
 노이즈 제거 텍스트 정규화  노이즈 제거(Noise removal)는 불필요한 태그 제거, 특수 문자 제거, 구두점 제거, 공백 제거등 실질 데이터와 무관한 문자를 삭제해 단어나 문장 인식을 명확히 할 수 있도록 만드는 전 처리 단계다. 텍스트 정규화(Text normalization)는 계산량을 줄이기 위한 처리다. 텀 매트릭스의 차원 축소(dimensionally reduction)을 축소해 계산을 빠르고 효율적이도록 한다.
                    </p>
                    <p class="article-more-link">
                        <a href="/nlp/text-preprocessing/">More</a>
                    </p>
                </div>

                
            </div>
        </article>
        

        

<nav id="page-nav">
    
    <a href="/page/6/" rel="prev" class="extend prev">&laquo; Prev</a>
    
    
    
    <a href="/">1</a>
    
    
    
    <a href="/page/2/">2</a>
    
    
    
    <a href="/page/3/">3</a>
    
    
    
    <a href="/page/4/">4</a>
    
    
    
    <a href="/page/5/">5</a>
    
    
    
    <a href="/page/6/">6</a>
    
    
    
    <span class="page-number current">7</span>
    
    
    
    <a href="/page/8/">8</a>
    
    
    
    <a href="/page/9/">9</a>
    
    
    
    <a href="/page/10/">10</a>
    
    
    
    <a href="/page/11/">11</a>
    
    
    
    <a href="/page/12/">12</a>
    
    
    
    <a href="/page/13/">13</a>
    
    
    
    <a href="/page/14/">14</a>
    
    
    
    <a href="/page/15/">15</a>
    
    
    
    <a href="/page/16/">16</a>
    
    
    
    <a href="/page/17/">17</a>
    
    
    
    <a href="/page/18/">18</a>
    
    

    
    <a href="/page/8/" rel="next" class="extend next">Next &raquo;</a>
    
</nav>

    </section>
    <footer id="footer">
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
