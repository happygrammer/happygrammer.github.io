<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>해피그의 코드랩</title>
    <link>https://happygrammer.github.io/</link>
    <description>Recent content on 해피그의 코드랩</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Apr 2024 05:43:02 +0900</lastBuildDate>
    
	<atom:link href="https://happygrammer.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM 메모리 구조 이해하기</title>
      <link>https://happygrammer.github.io/dev/java/understanding-jvm-memory-structure/</link>
      <pubDate>Fri, 12 Apr 2024 05:43:02 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/understanding-jvm-memory-structure/</guid>
      <description>JVM 메모리 구조 JVM(Java Virtual Machine)은 자바 프로그램을 실행하기 위한 가상 머신으로, 자바 코드를 바이트코드로 컴파일하고 이를 실행합니다. JVM은 메모리 관리를 위해 다양한 영역으로 구분되어 있으며, 이를 이해하는 것은 자바 개발자에게 중요한 역량입니다.
JVM 메모리는 크게 네이티브 영역과 VM 영역으로 나뉩니다. 네이티브 영역에는 텍스트, 데이터, 힙, 스택 등이 존재하며, 이는 일반적인 프로그램 실행에 필요한 메모리 영역입니다.
VM 영역은 자바 클래스를 구동하기 위한 전용 메모리 영역으로, 네이티브 영역과 유사한 역할을 수행합니다. VM 영역에는 다음과 같은 주요 메모리 영역이 있습니다:</description>
    </item>
    
    <item>
      <title>개발자를 위한 질문의 기술</title>
      <link>https://happygrammer.github.io/insights/the-art-of-asking-questions/</link>
      <pubDate>Fri, 12 Apr 2024 05:30:55 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/the-art-of-asking-questions/</guid>
      <description>안녕하세요, 저는 오늘 질문의 기술에 대해 이야기해보려고 합니다. 질문은 우리가 새로운 것을 배우고, 상대방과 소통하며, 문제를 해결하는 데 있어 매우 중요한 역할을 합니다. 하지만 많은 사람들이 질문하는 것을 두려워하거나, 질문을 어떻게 해야 할지 모르는 경우가 많습니다.
먼저, 질문을 할 때는 폭넓고 개방적인 질문을 하는 것이 좋습니다. 단순히 &amp;ldquo;예&amp;rdquo; 또는 &amp;ldquo;아니오&amp;quot;로 대답할 수 있는 질문보다는, 상대방이 자신의 생각과 의견을 자유롭게 표현할 수 있는 질문을 하는 것이 효과적입니다. 예를 들어, &amp;ldquo;이 프로젝트에 대해 어떻게 생각하시나요?</description>
    </item>
    
    <item>
      <title>delimiter 종류와 선택 가이드</title>
      <link>https://happygrammer.github.io/dev/choosing-splitters-for-data-fields/</link>
      <pubDate>Wed, 03 Apr 2024 07:16:52 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/choosing-splitters-for-data-fields/</guid>
      <description>Delimiter(구분문자)는 데이터를 분할하거나 구분하는 데 사용되는 문자 또는 문자열을 말합니다. 주로 데이터를 필드 또는 열 단위로 나눌 때 사용됩니다. 예를 들어, &amp;ldquo;apple,banana,cherry&amp;quot;라는 문자열이 있을 때, 콤마(,)를 Delimiter로 사용하면 &amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;cherry&amp;quot;의 세 부분으로 나눌 수 있습니다. 데이터를 다룰 때 각 필드를 명확하게 구분할 수 있는 적절한 Delimiter를 선택하는 것이 중요합니다. 좋은 Delimiter는 데이터의 가독성을 높이고, 데이터 처리 과정에서 오류를 줄이는 데 도움을 줍니다. 다음은 데이터 필드를 구분할 때 사용할 수 있는 Delimiter들입니다:</description>
    </item>
    
    <item>
      <title>자바스크립트 콜백 함수로 의존성 제거하기</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/removing-dependencies-with-callback-functions-in-javascript/</link>
      <pubDate>Tue, 02 Apr 2024 00:15:28 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/removing-dependencies-with-callback-functions-in-javascript/</guid>
      <description>자바스크립트에서 콜백 함수를 활용하면 의존성을 제거하고 코드의 재사용성을 높일 수 있습니다. 특히, 다른 메서드를 호출할 때 req와 res 객체를 직접 전달하는 대신 콜백 함수를 전달하는 방식은 많은 이점을 가져다 줍니다.
전통적인 방식에서는 한 메서드가 다른 메서드를 호출할 때 req와 res 객체를 인자로 전달합니다. 이는 메서드 간의 결합도를 높이고, 코드의 재사용성을 떨어뜨립니다. 또한, 메서드의 책임이 명확하지 않아 유지보수가 어려워질 수 있습니다.
반면에, 콜백 함수를 사용하면 이러한 문제를 해결할 수 있습니다. 호출되는 메서드는 req와 res 객체에 대한 의존성이 없어지고, 오직 콜백 함수를 통해서만 결과를 전달받습니다.</description>
    </item>
    
    <item>
      <title>개발자 경력의 핵심 요소들</title>
      <link>https://happygrammer.github.io/insights/essential-elements-developer-career/</link>
      <pubDate>Tue, 02 Apr 2024 00:03:48 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/essential-elements-developer-career/</guid>
      <description>개발자로서의 경력을 쌓아 나가는 데 있어, 기술적 역량 못지않게 중요한 것이 바로 팀 조직과 개발 프로세스에 대한 경험입니다. 이는 개발자의 성장에 있어 결정적인 역할을 합니다.
우선, 애자일 프로세스는 팀이 유연하고 적응력 있게 일할 수 있도록 도와줍니다. 고객 요구사항의 변화에 신속히 대응하고, 짧은 주기로 작동 가능한 소프트웨어를 제공하는 것이 핵심입니다. 짝 프로그래밍은 두 명의 개발자가 한 컴퓨터에서 함께 작업하는 방식으로, 실시간 코드 리뷰와 지식 공유가 이루어집니다. 이는 코드 품질 향상과 팀워크 강화에 큰 도움이 됩니다.</description>
    </item>
    
    <item>
      <title>개발자의 프레젠테이션 비결</title>
      <link>https://happygrammer.github.io/insights/developer-presentation-tips/</link>
      <pubDate>Mon, 01 Apr 2024 23:52:04 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/developer-presentation-tips/</guid>
      <description>개발자로서 우리는 종종 후배 개발자들에게 지식을 전달하고 경험을 공유할 기회를 갖게 됩니다. 이때 어떻게 하면 효과적으로 전달할 수 있을까요? TED 대표 크리스 앤더슨의 조언을 참고해 보는 것은 어떨까요?
먼저, 프레젠테이션의 핵심 아이디어에 초점을 맞추는 것이 중요합니다. 모든 내용이 이 중심 주제와 연결되어야 합니다. 청중이 주제에서 벗어나지 않도록 이끄는 것이 관건이죠.
다음으로, 청중과 친밀감을 형성하세요. eye contact를 유지하고 솔직하게 자신의 약점을 드러내는 것도 좋습니다. 완벽함을 추구하기보다는 진정성을 보여주는 것이 오히려 강점이 될 수 있습니다.</description>
    </item>
    
    <item>
      <title>겸손한 개발자의 자세</title>
      <link>https://happygrammer.github.io/insights/humble-developer-attitude/</link>
      <pubDate>Mon, 01 Apr 2024 23:44:30 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/humble-developer-attitude/</guid>
      <description>개발자에게 있어 겸손은 매우 중요한 자질입니다. 세계적인 물리학자 리처드 파인만의 명언에 이런 말이 있죠. &amp;ldquo;The more you know, the more you realize how little you know.&amp;rdquo; 우리가 알면 알수록, 우리가 모르는 것이 얼마나 많은지 깨닫게 된다는 뜻입니다.
개발 세계에서는 새로운 기술이 끊임없이 등장하고 있습니다. 잠시라도 주의를 놓치면 금세 뒤처질 수 있죠. 그렇기에 개발자는 항상 겸손한 자세를 유지하고, 자신이 아는 것이 많지 않다는 사실을 인지해야 합니다.
하지만 겸손하다는 것이 자신의 지식을 나누지 않는다는 뜻은 아닙니다.</description>
    </item>
    
    <item>
      <title>심볼릭 링크 사용시 주의사항</title>
      <link>https://happygrammer.github.io/dev/linux/symbolic-link-caution/</link>
      <pubDate>Mon, 01 Apr 2024 23:36:13 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/symbolic-link-caution/</guid>
      <description>심볼릭 링크(Symbolic Link)는 유닉스 계열 운영체제에서 파일이나 디렉터리에 대한 참조를 만드는 방법입니다. 이를 통해 파일 시스템 내에서 파일이나 디렉터리를 여러 위치에서 접근할 수 있게 됩니다. 하지만 심볼릭 링크 사용에는 주의해야 할 사항이 있습니다.
첫째, 심볼릭 링크는 읽기 전용으로 관리하는 것이 좋습니다. 심볼릭 링크 자체를 수정하기보다는 원본 파일을 변경하는 것이 안전합니다. 이는 심볼릭 링크의 무결성을 유지하고, 예기치 않은 문제를 방지하는 데 도움이 됩니다.
둘째, 심볼릭 링크가 가리키는 원본 파일이 삭제되거나 이동되면 링크가 깨질 수 있습니다.</description>
    </item>
    
    <item>
      <title>[프롬프팅] 프롬프트와 프롬프팅의 차이점 이해</title>
      <link>https://happygrammer.github.io/nlp/prompting/understanding-difference-between-prompt-and-prompting/</link>
      <pubDate>Mon, 01 Apr 2024 07:28:00 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/prompting/understanding-difference-between-prompt-and-prompting/</guid>
      <description>안녕하세요, 여러분! 오늘은 대화형 AI 시스템에서 중요한 개념인 프롬프트(Prompt)와 프롬프팅(Prompting)에 대해 알아보려고 합니다. 이 두 용어는 비슷해 보이지만, 사실 약간의 차이가 있습니다.
프롬프트 프롬프트는 AI 모델에 제공되는 입력 텍스트를 의미합니다. 사용자가 AI 모델과 상호 작용할 때, 프롬프트를 통해 대화를 시작하게 됩니다. 프롬프트는 질문, 지시문, 문맥 정보 등을 포함할 수 있으며, AI 모델이 생성할 응답의 방향을 결정하는 데 중요한 역할을 합니다. 예를 들어, &amp;ldquo;오늘 날씨가 어떤지 알려줘&amp;quot;라는 프롬프트를 제공하면, AI 모델은 해당 지역의 날씨 정보를 생성하게 됩니다.</description>
    </item>
    
    <item>
      <title>학습셋 통계 내기</title>
      <link>https://happygrammer.github.io/dev/linux/analyze_dataset/</link>
      <pubDate>Sun, 31 Mar 2024 22:18:21 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/analyze_dataset/</guid>
      <description>머신러닝이나 자연어처리 프로젝트를 진행할 때, 학습셋에 대한 통계를 내는 것은 매우 중요합니다. 이를 통해 데이터의 분포를 파악하고, 모델 성능에 영향을 줄 수 있는 요인을 찾아낼 수 있기 때문입니다.
data.set와 같은 학습셋 파일에서 통계를 내기 위해 다음과 같은 쉘 명령어를 사용할 수 있습니다.
cut -f &amp;lt;tab_position&amp;gt; &amp;lt;file_name&amp;gt; | sort | uniq -c data.set 파일에서 마지막 탭(\\t) 값을 기준으로 각 값의 개수를 출력하려면 다음과 같이 명령을 입력합니다.
cut -f $(($(head -n1 data.set | tr -cd &#39;\t&#39; | wc -c)+1)) data.</description>
    </item>
    
    <item>
      <title>제텔카스텐으로 글쓰기 혁신하기</title>
      <link>https://happygrammer.github.io/insights/zettelkasten_writing_innovation/</link>
      <pubDate>Sun, 31 Mar 2024 12:21:01 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/zettelkasten_writing_innovation/</guid>
      <description>안녕하세요, 개발자 여러분! 오늘은 글쓰기에 혁신을 가져다 줄 수 있는 제텔카스텐(Zettelkasten) 기법에 대해 소개하고자 합니다.
제텔카스텐이란? 제텔카스텐은 독일어로 &amp;ldquo;메모 상자&amp;quot;를 의미하는 단어입니다. 이는 철학자이자 사회학자인 니클라스 루만(Niklas Luhmann)이 개발한 지식 관리 시스템으로, 작은 메모들을 연결하여 새로운 아이디어와 통찰을 얻는 방법론입니다.
제텔카스텐의 핵심 원리  새로운 교훈을 다른 사람이 이해할 수 있도록 짧게 정리한 메모를 쓴다. 기존 노트와 연결한다. 특정 주제로 묶을 수 있도록 메모를 충분히 쌓고, 그것들을 연결해서 긴 글을 쓴다.</description>
    </item>
    
    <item>
      <title>AI 시대의 개발자 전망</title>
      <link>https://happygrammer.github.io/insights/ai-and-developer-future/</link>
      <pubDate>Sun, 31 Mar 2024 09:44:09 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/ai-and-developer-future/</guid>
      <description>최근 cognition-labs 데빈(Devin)이라는 AI가 등장하여 자동으로 코딩을 처리한다는 소식이 개발자 커뮤니티에 큰 파장을 일으키고 있습니다. GPT와 같은 대규모 언어 모델(Larse Language Model, LLM)의 발전으로 인해 리팩토링, 단순한 코드, 그리고 알려진 패턴의 코드 작성은 이제 AI의 영역이 된 것으로 보입니다.
 AI가 개발자들의 시간을 절약해 준다는 점은 분명한 사실입니다. 그러나 역설적이게도, 개발해야 할 일들은 오히려 더 늘어나고 있습니다. 우리는 점점 더 빠른 속도로 움직여야 하는 개발자로 변모하고 있으며, 이로 인해 개발의 본질적인 재미와 창의성이 사라지는 것 같아 안타까운 마음이 듭니다.</description>
    </item>
    
    <item>
      <title>파이썬 for 루프 마스터하기</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-for-loops/</link>
      <pubDate>Sun, 31 Mar 2024 04:33:40 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-for-loops/</guid>
      <description>안녕하세요, 파이썬 개발자 여러분! 오늘은 리스트의 요소를 출력하는 다양한 종류의 for 루프 사용법에 대해 알아보겠습니다.
먼저, 주어진 리스트 a를 살펴봅시다.
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]  for-each 루프를 사용하여 리스트의 요소를 하나씩 출력할 수 있습니다.  for element in a: print(element, end=&#39; &#39;) print() 인덱스를 사용한 for 루프로 리스트의 요소에 접근할 수도 있습니다.  for i in range(len(a)): print(a[i], end=&#39; &#39;) print() while 루프와 인덱스를 활용하여 리스트의 요소를 출력할 수 있습니다.</description>
    </item>
    
    <item>
      <title>파이썬 컴프리헨션: 한 줄로 자료구조 다루기</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-comprehensions-for-concise-code/</link>
      <pubDate>Sun, 31 Mar 2024 04:25:40 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-comprehensions-for-concise-code/</guid>
      <description>안녕하세요, 파이썬 개발자 여러분! 오늘은 파이썬에서 자료구조를 더욱 효율적이고 간결하게 표현할 수 있는 컴프리헨션(Comprehension) 문법에 대해 알아보겠습니다.
컴프리헨션은 리스트, 딕셔너리, 세트 등의 자료구조를 생성할 때 사용할 수 있는 강력한 문법입니다. 간단한 예시를 통해 살펴보겠습니다.
먼저, 리스트 컴프리헨션을 사용하여 리스트 &amp;lsquo;a&#39;에서 2보다 큰 요소로 이루어진 새 리스트 &amp;lsquo;b&#39;를 생성해보겠습니다.
a = [1, 2, 3, 4] b = [i for i in a if i &amp;gt; 2] print(b) # [3, 4] 리스트 컴프리헨션을 사용하면 한 줄의 코드로 간결하게 새로운 리스트를 생성할 수 있습니다.</description>
    </item>
    
    <item>
      <title>코드로 풀어보는 행복의 알고리즘</title>
      <link>https://happygrammer.github.io/insights/life-lessons-from-park-chu-young/</link>
      <pubDate>Sun, 31 Mar 2024 03:52:18 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/life-lessons-from-park-chu-young/</guid>
      <description>안녕하세요, 독자 여러분. 오늘은 축구선수 박주영의 사례를 통해 우리 삶에 적용할 수 있는 교훈에 대해 생각해보려 합니다. 박주영 선수는 한때 한국 축구의 미래로 불리며 큰 기대를 모았습니다. 하지만 세계 최고 리그인 잉글랜드 프리미어 리그로 이적한 후, 주전 경쟁에서 밀리며 어려움을 겪었죠. 기대만큼의 활약을 보여주지 못한 것이지요. 이는 우리가 인생의 선택의 기로에 섰을 때도 마찬가지입니다. 예를 들어 대학을 선택할 때, 많은 학생들이 이름난 명문대만 바라보곤 합니다. 하지만 그보다 덜 유명한 대학에 진학해서도 열심히 노력하며 멋진 성과를 이뤄낸 사람들이 많습니다.</description>
    </item>
    
    <item>
      <title>코드로 풀어보는 명화의 가치 평가 알고리즘</title>
      <link>https://happygrammer.github.io/insights/factors-behind-picasso-paintings-value/</link>
      <pubDate>Sun, 31 Mar 2024 03:42:48 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/factors-behind-picasso-paintings-value/</guid>
      <description>안녕하세요, 미술 애호가 여러분! 오늘은 피카소의 그림이 높은 가치를 지니는 이유에 대해 알아보도록 하겠습니다.
첫째, 피카소는 전에 없던 혁신적인 작품을 선보였습니다. 그의 작품은 후대 작가들에게 영감을 주었고, 현대 미술의 발전에 큰 기여를 했습니다.
둘째, 피카소는 순수한 추상미술과 콜라주 기법을 도입하여 새로운 표현 방식을 제시했습니다. 이는 그의 작품 가치를 더욱 높이는 요인으로 작용합니다.
또한, 그림의 가격 형성에는 소장 기록(Provenance)이 중요한 역할을 합니다. 작품을 보유했던 사람, 중개 딜러, 전시 장소 등의 정보는 그림의 가치에 영향을 미칩니다.</description>
    </item>
    
    <item>
      <title>개발자도 모든 것을 이해할 순 없습니다</title>
      <link>https://happygrammer.github.io/insights/accepting-differences/</link>
      <pubDate>Sun, 31 Mar 2024 03:11:24 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/accepting-differences/</guid>
      <description>우리는 종종 상대방의 행동이나 생각이 이해가 가지 않을 때가 있습니다. 그럴 때 많은 사람들은 &amp;ldquo;그냥 그런가 보다&amp;quot;라고 생각하곤 합니다. 하지만 이것은 단순히 상황을 회피하는 것일 수 있습니다.
사실 모든 것을 이해하는 사람은 없습니다. 우리 각자는 자신만의 경험, 가치관, 성격을 가지고 있기 때문입니다. 따라서 서로 다른 것은 당연한 일이며, 이를 인정하는 것이 중요합니다.
유명한 심리학자 칼 융은 이렇게 말했습니다:
 &amp;ldquo;The meeting of two personalities is like the contact of two chemical substances: if there is any reaction, both are transformed.</description>
    </item>
    
    <item>
      <title>앱 정리, 이렇게 하세요!</title>
      <link>https://happygrammer.github.io/insights/app-organization-tips/</link>
      <pubDate>Sun, 31 Mar 2024 03:06:37 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/app-organization-tips/</guid>
      <description>앱이 많아짐에 따라 관리가 어려워질 수 있습니다. 이럴 때는 앱을 폴더별로 분류하여 관리하는 것이 효과적입니다. 폴더 구조를 잘 짜는 것만으로도 앱 관리에 큰 도움이 됩니다.
폴더 내 앱 정렬 시에는 가장 자주 사용하는 앱을 최상위에 배치하고, 그 다음으로는 최근에 사용한 앱 순으로 정렬하는 것이 좋습니다. 이렇게 하면 필요한 앱을 빠르게 찾을 수 있습니다.
그 외에 이름순, 확장자순, 용량순 정렬은 특정 목적이 있을 때만 사용하는 것이 좋습니다. 예를 들어, txt 파일만 따로 모아야 할 때는 확장자순으로, 파일 정리 시에는 용량순으로 정렬하면 편리합니다.</description>
    </item>
    
    <item>
      <title>개발자를 위한 습관 형성 전략</title>
      <link>https://happygrammer.github.io/insights/habit_formation_for_developers/</link>
      <pubDate>Sun, 31 Mar 2024 02:49:31 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/habit_formation_for_developers/</guid>
      <description>안녕하세요, 개발자 여러분! 습관 형성은 우리 개발자들에게도 매우 중요한 주제입니다. 코딩을 무의식적으로 하거나 새로운 언어를 자연스럽게 익히는 것, 이 모든 것이 바로 습관의 힘이라고 할 수 있죠. 하지만 많은 분들이 습관 형성을 단순히 반복의 산물로 생각하는 경향이 있습니다. 과연 그럴까요?
습관 형성의 핵심은 자신에게 동기부여가 되는 것을 찾고, 그것을 꾸준히 실천하는 데 있습니다. 개발자에게 있어 이는 더욱 중요한데, 우리는 늘 새로운 기술과 언어를 학습해야 하기 때문이죠. 단순히 책을 읽거나 강의를 듣는 것만으로는 부족합니다.</description>
    </item>
    
    <item>
      <title>개발자라면 파인만처럼 만들자</title>
      <link>https://happygrammer.github.io/insights/make_it_like_feynman/</link>
      <pubDate>Sun, 31 Mar 2024 02:11:01 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/make_it_like_feynman/</guid>
      <description>리처드 파인만은 노벨 물리학상을 수상한 세계적인 물리학자입니다. 그는 &amp;ldquo;What I cannot create, I do not understand.&amp;ldquo;이라는 유명한 말을 남겼는데, 이를 한국어로 번역하면 &amp;quot;만들지 못하는 것은 이해도 하지 못한다.&amp;quot;입니다.
def understand(concept): try: create(concept) return True except: return False 위 코드는 파인만의 사상을 단순화시킨 예시입니다. 어떤 개념을 진정으로 이해했는지 확인하는 방법은 그것을 직접 만들어보는 것입니다. 만약 만들 수 없다면 아직 완전히 이해하지 못한 것이죠.
이는 개발자에게도 마찬가지입니다. 우리는 종종 새로운 기술이나 개념을 접하게 됩니다.</description>
    </item>
    
    <item>
      <title>Ml 모델과 Data 퀄리티</title>
      <link>https://happygrammer.github.io/mlops/ml-models-and-data-quality/</link>
      <pubDate>Sun, 31 Mar 2024 00:15:15 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/ml-models-and-data-quality/</guid>
      <description>안녕하세요, 여러분. 오늘은 머신러닝(ML) 모델의 성능에 가장 큰 영향을 미치는 요소 중 하나인 데이터 품질에 대해 이야기하려 합니다. &amp;ldquo;쓰레기가 들어가면 쓰레기가 나온다&amp;quot;라는 말이 있듯이, ML 모델은 학습에 사용되는 데이터만큼만 신뢰할 수 있습니다. 따라서 양질의 데이터를 확보하는 것은 ML 프로젝트 성공의 핵심입니다.
양질의 데이터란 무엇일까요? 양질의 데이터는 다음과 같은 특징을 가지고 있습니다:
 정확성: 데이터가 현실 세계를 정확하게 반영해야 합니다. 완전성: 데이터에 누락된 값이 없어야 합니다. 일관성: 데이터 간에 모순이 없어야 합니다.</description>
    </item>
    
    <item>
      <title>AI Ops의 주역들</title>
      <link>https://happygrammer.github.io/dev/ai-ops-key-players/</link>
      <pubDate>Sat, 30 Mar 2024 23:53:06 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/ai-ops-key-players/</guid>
      <description>안녕하세요, 여러분. 오늘은 AI Ops에서 핵심적인 역할을 담당하는 전문가들에 대해 알아보겠습니다. AI Ops는 인공지능 시스템의 개발과 운영에 있어 다양한 분야의 전문가들 간의 긴밀한 협업이 필수불가결한 영역입니다.
먼저, 연구 과학자는 AI Ops에서 ML(Machine Learning) 분야의 발전을 이끄는 핵심 인력입니다. 이들은 새로운 알고리즘을 연구하고 개발함으로써 AI 기술의 혁신을 주도합니다. 최신 연구 동향을 파악하고, 실험을 통해 알고리즘의 성능을 검증하며, 학술 논문을 통해 연구 결과를 공유하는 것이 연구 과학자들의 주요 업무입니다. 다음은 TensorFlow를 사용하여 새로운 Neural Network 모델을 정의하는 예시 코드입니다.</description>
    </item>
    
    <item>
      <title>Git을 일관되게 사용하는 팁</title>
      <link>https://happygrammer.github.io/dev/git/git_convention/</link>
      <pubDate>Sat, 30 Mar 2024 23:45:09 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git_convention/</guid>
      <description>안녕하세요, 여러분! 오늘은 Git을 사용할 때 일관성을 유지하는 방법에 대해 이야기해 보려고 합니다. Git은 강력한 버전 관리 도구이지만, 팀원들 간의 사용 방식이 제각각이라면 혼란을 겪을 수 있습니다. 이런 문제를 해결하기 위해 몇 가지 팁을 공유하고자 합니다.
 Git 사용 규칙 만들기  팀원들과 함께 Git 사용 규칙을 정해 보세요. 예를 들어, 커밋 메시지 작성 방법, 브랜치 명명 규칙, 코드 리뷰 프로세스 등을 포함할 수 있습니다. 규칙을 문서화하여 모든 팀원이 쉽게 참조할 수 있도록 해 주세요.</description>
    </item>
    
    <item>
      <title>Git 저장소 히스토리 초기화하기</title>
      <link>https://happygrammer.github.io/dev/git/git-repository-reset/</link>
      <pubDate>Sat, 30 Mar 2024 23:20:00 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git-repository-reset/</guid>
      <description>안녕하세요, 여러분! 오늘은 Git 저장소의 히스토리를 초기화하는 방법에 대해 알아보도록 하겠습니다. 가끔 프로젝트를 진행하다 보면, 저장소의 커밋 히스토리를 초기화해야 할 때가 있죠. 그럴 때 아래 방법을 따라해 보시면 쉽게 해결할 수 있습니다.
먼저, 작업을 진행하는 로컬 컴퓨터에 Git이 설치되어 있는지 확인해 주세요. 터미널에서 아래 명령어를 입력하면 설치된 Git의 버전을 확인할 수 있습니다.
$ git --version git version 2.39.0 Git이 설치되어 있다면, 아래 단계를 따라 저장소 히스토리를 초기화해 봅시다.
 새로운 브랜치 생성  git checkout --orphan tmp_branch 명령어를 사용하여 tmp_branch라는 이름의 새 브랜치를 생성합니다.</description>
    </item>
    
    <item>
      <title>개발자의 필수 스킬, 핵심 기술력 키우기</title>
      <link>https://happygrammer.github.io/insights/mastering-core-technologies/</link>
      <pubDate>Fri, 01 Mar 2024 03:24:41 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/mastering-core-technologies/</guid>
      <description>안녕하세요, 독자 여러분! 오늘은 개발자로서 성공하기 위해 필수적인 핵심 기술력에 대해 이야기하고자 합니다.
변두리 기술에 집중하기보다는 자신만의 핵심 기술력을 확보하는 것이 중요합니다. 프레드 브룩스의 말처럼 &amp;ldquo;과학자는 배우기 위해 개발하지만 엔지니어는 개발하기 위해 배웁니다.&amp;rdquo; 우리는 엔지니어로서 개발에 필요한 기술을 배우고 익혀야 합니다.
핵심 기술력을 키우기 위해서는 끊임없는 학습과 실践이 필요합니다. 게으른 사람에게 어려운 일을 맡기면 쉽게 처리하는 방법을 찾아낸다는 말처럼, 우리도 효율적인 방법을 찾아야 합니다. 이를 위해 다음과 같은 코드를 참고해 보세요:</description>
    </item>
    
    <item>
      <title>개발자라면 아인슈타인처럼!</title>
      <link>https://happygrammer.github.io/insights/curiosity_for_developers/</link>
      <pubDate>Sun, 25 Feb 2024 02:30:52 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/curiosity_for_developers/</guid>
      <description>안녕하세요, 독자 여러분. 오늘은 위대한 과학자 알버트 아인슈타인의 삶에서 개발자로서 배울 수 있는 교훈에 대해 이야기해보려 합니다.
 열정적인 호기심을 가져라    &amp;ldquo;I have no special talents. I am only passionately curious.&amp;rdquo; &amp;ldquo;나는 특별한 재능을 갖지 못했다. 다만 호기심이 유달리 강하였을 뿐이다.&amp;rdquo;
 아인슈타인은 자신의 성공 비결로 열정적인 호기심을 꼽았습니다. 개발자에게도 새로운 기술과 지식에 대한 호기심은 성장의 원동력이 됩니다.
인내하라!    &amp;ldquo;I&#39;m not particularly clever. I just stick with the problems longer.</description>
    </item>
    
    <item>
      <title>목적에 맞는 개발 언어 찾기</title>
      <link>https://happygrammer.github.io/insights/choosing_the_right_programming_language/</link>
      <pubDate>Thu, 15 Feb 2024 11:51:02 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/choosing_the_right_programming_language/</guid>
      <description>안녕하세요, 개발자 여러분! 오늘은 다양한 프로그래밍 언어의 목적과 특징에 대해 알아보고, 여러분의 프로젝트에 가장 적합한 언어를 선택하는 방법에 대해 이야기해보려 합니다.
먼저, 웹 개발에서 가장 기본이 되는 언어들을 살펴보겠습니다:
 HTML: 웹 페이지의 구조(Structure)를 정의하는 데 사용됩니다. CSS: 웹 페이지의 스타일(Style)을 지정하는 역할을 합니다. JavaScript: 웹 페이지에 인터랙티브한 요소(Fun)를 추가합니다. React: 효율적인 사용자 인터페이스를 구축하여 작업(Work)을 단순화합니다. Angular: TypeScript 기반의 웹 애플리케이션 프레임워크로, 대규모 프로젝트에 적합합니다. Vue.js: 간편하고 직관적인 웹 애플리케이션 개발을 위한 프레임워크입니다.</description>
    </item>
    
    <item>
      <title>코드로 구현하는 머니볼</title>
      <link>https://happygrammer.github.io/insights/moneyball-strategy-for-team-success/</link>
      <pubDate>Sat, 10 Feb 2024 03:57:47 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/moneyball-strategy-for-team-success/</guid>
      <description>안녕하세요, 스포츠 팬 여러분! 오늘은 야구 구단 운영에 혁신을 가져온 머니볼 전략에 대해 알아보겠습니다.
머니볼 전략의 핵심은 다음과 같습니다:
 나보다 뛰어난 스태프 고용 스포츠에 대한 열정 필요 성별과 국적에 관계없는 직원 채용 수퍼스타보다는 평균 이상의 선수들로 팀 구성하여 서로의 단점 보완 (원 소스 멀티유즈)  머니볼 실현을 위한 5단계는 다음과 같습니다:
 목표 설정: TV 시청률 or 관중 수 증대 등 명확한 목표 설정 한계가치 계산: 승패에 영향을 미치는 핵심 지표 파악 및 선수별 한계가치 산출 한계가치의 균등화: 스타 선수보다는 여러 선수 영입으로 한계가치 분산 거래와 투자: 저평가된 선수 영입, 고평가된 선수 판매 or 은퇴로 효율적 거래와 투자 조직 설계: 출루율 높은 선수는 장타율 향상 전략 구성 등 팀 내 조직 설계  다음은 Python으로 구현한 머니볼 전략 예시입니다:</description>
    </item>
    
    <item>
      <title>코드로 풀어보는 효율적 업무 처리</title>
      <link>https://happygrammer.github.io/insights/grasping-the-core-of-work-and-efficient-task-management/</link>
      <pubDate>Thu, 01 Feb 2024 04:44:36 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/grasping-the-core-of-work-and-efficient-task-management/</guid>
      <description>안녕하세요, 업무 효율성 향상에 관심 있는 여러분! 오늘은 일의 맥을 잘 짚는 것이 얼마나 중요한지, 그리고 이를 통해 어떻게 효율적으로 업무를 처리할 수 있는지에 대해 이야기해보려 합니다.
우선, 일의 맥을 잘 짚는다는 것은 업무의 핵심을 파악하는 것을 의미합니다. 일의 핵심은 사실 별것 아닙니다. 업무 처리 단계별로 중요한 내용을 의사결정자와 논의하고 결정하면 됩니다.
효율적인 업무 처리를 위해서는 혼자 결정할 사항과 다른 사람들과 함께 결정해야 할 사항을 구분하는 것이 중요합니다. 이를 위해서는 업무 처리 단계별로 결정 사항을 정리하고, 필요한 사람들과 소통하면서 진행해야 합니다.</description>
    </item>
    
    <item>
      <title>개발자가 본 도구의 본질</title>
      <link>https://happygrammer.github.io/insights/essence_of_tools/</link>
      <pubDate>Thu, 01 Feb 2024 01:47:23 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/essence_of_tools/</guid>
      <description>우리는 살면서 도구를 사용하지 않을 때가 없습니다. 벽에 액자를 걸려고 해도 망치라는 도구가 필요하고, 종이를 자르려고 하면 가위라는 도구가 필요합니다. 도구는 저마다 목적을 가지고 있습니다. 사전적 정의에 따르면 도구(道具)란 다음 두 가지 의미를 갖습니다.
 &amp;lsquo;일을 할 때 쓰는 연장을 통틀어 이르는 말&amp;rsquo; &amp;lsquo;어떤 목적을 이루기 위한 수단이나 방법&amp;rsquo;  여기서는 &amp;lsquo;어떤 목적을 이루기 위한 수단이나 방법&#39;으로서의 도구에 대해 살펴보겠습니다. 한자어 도구(道具)의 의미를 보면, 道(길, 도리, 이치, 재주), 具(갖추다, 구비하다, 온전하다)라는 뜻을 담고 있습니다.</description>
    </item>
    
    <item>
      <title>개발자의 상상력과 호기심</title>
      <link>https://happygrammer.github.io/insights/imagination_and_curiosity/</link>
      <pubDate>Thu, 01 Feb 2024 01:43:58 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/imagination_and_curiosity/</guid>
      <description>상상력은 어떻게 정의할 수 있을까요? 사전에서는 &amp;quot;실제로 경험하지 않은 현상이나 사물에 대하여 마음속으로 그려 보는 힘&amp;quot;이라고 정의하고 있습니다. 하지만 저는 조금 다른 관점에서 바라보고 싶습니다. 제 나름대로 정의한 상상력은 &amp;quot;제한을 가지지 않는 생각들을 구체화하는 힘&amp;quot;입니다.
상상력의 원천은 무엇일까요? 바로 호기심이라고 생각합니다. 호기심이 없다면 상상력을 발휘하기 어려울 것입니다. 그렇다면 호기심을 자극하기 위해서는 어떻게 해야 할까요? 지식으로 &amp;lsquo;정답&#39;을 제한하지 않는 것이 중요합니다. 정해진 틀에 갇히지 않고 자유롭게 사고하는 것, 그것이 바로 상상력의 시작점이 되는 것입니다.</description>
    </item>
    
    <item>
      <title>개발자의 자존감을 높이는 마법의 말</title>
      <link>https://happygrammer.github.io/insights/magic_words_for_developers_self_esteem/</link>
      <pubDate>Tue, 30 Jan 2024 01:58:23 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/magic_words_for_developers_self_esteem/</guid>
      <description>개발자로서 우리는 종종 코딩에 막혀 좌절감을 느낄 때가 있습니다. 이럴 때 우리는 흔히 &amp;ldquo;I have to&amp;quot;라는 말을 사용하곤 합니다. &amp;ldquo;나는 이 버그를 고쳐야 해&amp;rdquo;, &amp;ldquo;나는 이 기능을 구현해야만 해&amp;quot;와 같은 식으로 말이죠.
그러나 이런 표현은 마치 우리가 외부의 압력에 의해 어쩔 수 없이 일을 해야 한다는 느낌을 줍니다. 이는 자존감을 낮추고 스트레스를 유발할 수 있습니다.
대신에 우리가 &amp;ldquo;I choose to&amp;quot;라는 말을 사용한다면 어떨까요? &amp;ldquo;나는 이 버그를 고치기로 선택했어&amp;rdquo;, &amp;ldquo;나는 이 기능을 구현하기로 결정했어&amp;quot;와 같이 말입니다.</description>
    </item>
    
    <item>
      <title>개발자의 성공 키워드, 속도</title>
      <link>https://happygrammer.github.io/insights/speed_is_key_to_success/</link>
      <pubDate>Thu, 25 Jan 2024 02:22:33 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/speed_is_key_to_success/</guid>
      <description>안녕하세요, 독자 여러분. 오늘은 개발자의 성공에 있어 속도가 얼마나 중요한지에 대해 이야기해보려 합니다.
성공하는 개발자들의 공통점 중 하나는 바로 빠른 실행력입니다. 그들은 완벽을 추구하기보다는 과감히 실천하는 경향이 있습니다. 물론 꼼꼼함도 중요하지만, 지나친 완벽주의는 오히려 발전을 더디게 만들 수 있습니다.
def achieve_success(idea): while True: plan = make_plan(idea) action = take_action(plan) result = evaluate(action) if is_successful(result): break idea = improve(result) 위 코드는 성공에 이르는 과정을 단순화하여 표현한 것입니다. 아이디어가 있다면 바로 실행 계획을 세우고, 주저하지 않고 행동으로 옮깁니다.</description>
    </item>
    
    <item>
      <title>OpenAI의 차별화된 인터페이스 전략</title>
      <link>https://happygrammer.github.io/insights/openai_differentiated_interface_strategy/</link>
      <pubDate>Sun, 21 Jan 2024 02:05:57 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/openai_differentiated_interface_strategy/</guid>
      <description>API를 아무리 잘 만들어도 결국 사용자와의 접점은 인터페이스라는 생각이 듭니다. OpenAI는 이 점을 잘 이해하고 있는 것 같습니다. 단순히 API를 제공하는 데 그치지 않고, 별도의 앱과 보이스 인터페이스 등을 지원함으로써 사용자 경험을 한층 더 높이고 있습니다.
class OpenAI: def __init__(self): self.api = self.create_api() self.app = self.create_app() self.voice_interface = self.create_voice_interface() def create_api(self): # Create a powerful API pass def create_app(self): # Create a user-friendly app pass def create_voice_interface(self): # Create an intuitive voice interface pass 위 코드는 OpenAI의 전략을 간단히 표현한 것입니다.</description>
    </item>
    
    <item>
      <title>개발 팀을 이끄는 리더십 전략</title>
      <link>https://happygrammer.github.io/insights/leadership-secrets-for-developers/</link>
      <pubDate>Wed, 10 Jan 2024 03:32:19 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/leadership-secrets-for-developers/</guid>
      <description>안녕하세요, 독자 여러분! 오늘은 리더십에 대해 이야기하고자 합니다. 리더십은 개발자에게도 매우 중요한 역량입니다.
리더십의 핵심은 쫓지 말고 리드하는 것입니다. 제로에서 시작하여 승리를 이끌어내려면 선두에 서서 팀을 이끌어야 합니다. 이를 위해서는 각 분야의 핵심 요점을 정리한 한 장의 요약지를 관리하는 것이 도움이 됩니다.
또한, 개발자로서 생존 코딩과 생존 글쓰기 능력을 갖추는 것이 중요합니다. 코딩과 글쓰기는 개발자의 기본 무기입니다. 다음 코드를 참고해 보세요:
def survive_as_developer(): while True: improve_coding_skills() practice_writing_skills() summarize_key_points() if became_a_leader(): break return &amp;quot;개발 팀의 리더가 되었습니다!</description>
    </item>
    
    <item>
      <title>개발에서의 품질 단서 활용</title>
      <link>https://happygrammer.github.io/insights/quality-cues-for-consumer-expectations/</link>
      <pubDate>Sat, 06 Jan 2024 01:25:03 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/quality-cues-for-consumer-expectations/</guid>
      <description>소비자는 제품을 구매할 때, 실제로 사용해보기 전에 제품의 포장이나 겉모습을 보고 판단한다. 이때 소비자의 기대를 좌우하는 것이 바로 품질 단서(quality cue) 또는 품질 신호(quality signal)이다.
품질 단서의 종류  도상(icon): 있는 그대로를 표현한 것. 예를 들어, 우유 패키지에 우유를 마시는 장면을 그려넣는 것. 지표(index): 간접적으로 사물을 인식할 수 있게 하는 표지. 계절밥상 매장의 식재료 사진이 이에 해당. 상징(symbol): 대상과 직접적 연관은 없지만, 의미를 부여하는 것. 덴마크 우유 포장의 명화가 이에 해당.</description>
    </item>
    
    <item>
      <title>구글 개발자의 겸손한 자세</title>
      <link>https://happygrammer.github.io/insights/google-developers-humility/</link>
      <pubDate>Fri, 05 Jan 2024 01:09:36 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/google-developers-humility/</guid>
      <description>구글에서 엔지니어로 일했던 첸 왕은 구글에서 최고로 손꼽혔던 개발자들 가운데 겸손한 개발자가 많다고 강조했다. 왕은 &amp;ldquo;구글의 강력한 인프라를 구축하는데 아주 중요한 역할을 한 개발자들이다. 그런데 이들 가운데 &amp;lsquo;지적 거만&#39;을 떠는 사람은 단 한 사람도 없었다&amp;quot;고 말했다.1
그는 &amp;ldquo;겸손만으로 뛰어난 개발자가 될 수는 없다. 그러나 통상 겸손하지 않은 개발자는 평범한 개발자&amp;quot;라고 덧붙였다. 이는 실력과 겸손함이 모두 갖추어져야 진정한 의미의 뛰어난 개발자가 될 수 있음을 시사한다.
구글의 성공 요인 중 하나는 이렇게 실력과 인성을 겸비한 개발자들의 존재가 아닐까?</description>
    </item>
    
    <item>
      <title>Git 브랜치 전략</title>
      <link>https://happygrammer.github.io/dev/git/git-branching-strategy/</link>
      <pubDate>Fri, 05 Jan 2024 00:59:29 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/git-branching-strategy/</guid>
      <description>안녕하세요, 여러분. 오늘은 Git의 브랜치 전략에 대해 알아보겠습니다. 효과적인 브랜치 전략은 협업과 코드 관리에 있어 매우 중요합니다. 브랜치를 잘 활용하면 안정적이고 효율적인 개발 프로세스를 구축할 수 있습니다.
일반적으로 사용되는 브랜치 종류로는 dev 통합, qa 통합, master 통합, hotfix 브랜치가 있습니다. 각 브랜치의 역할과 관계를 이해하는 것이 중요합니다.
 dev 브랜치: 개발 작업이 진행되는 메인 브랜치입니다. 모든 새로운 기능 개발은 dev 브랜치에서 시작됩니다. qa 브랜치: 테스트를 위한 브랜치로, dev 브랜치의 부모 브랜치입니다.</description>
    </item>
    
    <item>
      <title>좋은 개발자로 성장하기</title>
      <link>https://happygrammer.github.io/insights/becoming-a-good-developer/</link>
      <pubDate>Fri, 05 Jan 2024 00:46:13 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/becoming-a-good-developer/</guid>
      <description>안녕하세요, 개발자 여러분. 오늘은 좋은 개발자로 성장하기 위해 우리가 어떤 노력을 해야 하는지 이야기해보려 합니다. 개발자로서의 성장 과정은 결코 쉽지 않습니다. 열악한 환경 탓에 발전이 더뎌질 수도 있지만, 결국 개발자의 실력은 자신의 노력에 달려 있습니다.
저 역시 완벽하지는 않지만, 오랜 경험을 바탕으로 몇 가지 조언을 드리고자 합니다. 먼저, 새로운 기술에 도전하는 것이 중요합니다. 익숙한 기술에 안주하지 않고, 끊임없이 배우려는 자세가 필요합니다. 그리고 지식을 공유하기 위해 노력해야 합니다. 자신의 업무와 관련된 지식을 문서화하고, 팀원들과 공유하는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title>파이썬 예외 처리시 라인 번호 출력</title>
      <link>https://happygrammer.github.io/dev/language/python3/python-exception-lineno/</link>
      <pubDate>Mon, 01 Jan 2024 22:33:29 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python-exception-lineno/</guid>
      <description>파이썬에서 예외 처리를 할 때, 에러 메시지와 함께 해당 에러가 발생한 라인 번호를 출력하고 싶을 때가 있습니다. 이는 디버깅 과정에서 매우 유용할 수 있죠. 파이썬의 traceback 모듈을 사용하면 스택 추적 정보를 가져와서 예외가 발생한 파일 이름과 라인 번호를 확인할 수 있습니다. 아래 코드를 살펴봅시다.
import traceback try: # 예외 발생 가능한 코드 raise Exception(&amp;quot;예외 발생!&amp;quot;) except Exception as e: # 스택 추적 정보 가져오기 trace = traceback.format_exc() LOGGER.error(f&amp;quot;Failed to load dm.</description>
    </item>
    
    <item>
      <title>코드로 살펴보는 특허 명세서 작성 가이드</title>
      <link>https://happygrammer.github.io/insights/patent-specification-requirements/</link>
      <pubDate>Mon, 01 Jan 2024 03:38:50 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/patent-specification-requirements/</guid>
      <description>안녕하세요, 특허에 관심 있는 여러분! 오늘은 특허 명세서 작성 시 주의해야 할 기재불비에 대해 알아보도록 하겠습니다.
특허 명세서의 발명의 설명 부분은 해당 기술 분야의 통상의 지식을 가진 사람이 쉽게 발명을 실시할 수 있도록 작성되어야 합니다. 만약 이 요건을 충족하지 못한다면, 기재불비로 판단될 수 있습니다.
또한, 특허청구범위에 기재된 용어나 표현이 발명의 설명 부분에서 뒷받침되지 않거나, 그 의미가 불명확한 경우에도 기재불비에 해당됩니다.
예를 들어, 다음과 같은 코드가 특허청구범위에 기재되어 있다고 가정해 보겠습니다.</description>
    </item>
    
    <item>
      <title>책임 있는 AI 개발</title>
      <link>https://happygrammer.github.io/mlops/responsible-ai-development/</link>
      <pubDate>Mon, 01 Jan 2024 00:23:10 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/responsible-ai-development/</guid>
      <description>안녕하세요, 여러분. 오늘은 프로덕션 환경에서 책임감 있는 AI를 개발하는 방법에 대해 이야기하려 합니다. AI 시스템을 개발하고 배포할 때, 우리는 다양한 이해관계자들의 관점을 고려해야 합니다. 여기에는 모델 빌더, ML 엔지니어, 비즈니스 의사결정권자, 그리고 ML 시스템의 최종 사용자가 포함됩니다.
책임감 있는 AI를 만들기 위해서는 다음과 같은 원칙을 따라야 합니다:
 공정성과 편향성 최소화: AI 모델이 특정 집단에 대해 차별적인 결과를 내지 않도록 주의해야 합니다. 이를 위해 데이터의 편향성을 검토하고, 모델의 공정성을 평가하는 것이 중요합니다.</description>
    </item>
    
    <item>
      <title>개발자는 학벌보다 실력이다</title>
      <link>https://happygrammer.github.io/insights/skill_over_academic_background/</link>
      <pubDate>Mon, 25 Dec 2023 01:51:35 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/skill_over_academic_background/</guid>
      <description>회사가 원하는 개발자는 단순히 좋은 학교의 컴퓨터 공학과를 졸업한 사람이 아닙니다. 회사에서 진정으로 필요로 하는 것은 일을 잘하는 개발자입니다. 학벌보다 실력이 중요하다는 것은 개발자 업계에서 이미 공공연한 사실입니다.
&amp;quot;Action is the foundational key to all success.&amp;quot; - Pablo Picasso &amp;quot;행동은 모든 성공의 기초적인 열쇠이다.&amp;quot; - 파블로 피카소 피카소의 말처럼, 개발자에게 있어서도 실제로 코드를 작성하고 문제를 해결하는 행동이 성공의 핵심입니다. 아래 코드는 이러한 점을 잘 보여주는 예시입니다.
def solve_problem(problem): # Analyze the problem analysis = analyze(problem) # Plan a solution solution = plan(analysis) # Implement the solution result = implement(solution) return result 위 코드에서 볼 수 있듯이, 문제를 분석하고(analyze) 해결책을 계획하며(plan) 이를 실제로 구현하는(implement) 일련의 과정이 개발자의 실력을 나타냅니다.</description>
    </item>
    
    <item>
      <title>LIMA 논문 리뷰</title>
      <link>https://happygrammer.github.io/nlp/review/lima/</link>
      <pubDate>Sat, 24 Jun 2023 14:15:31 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/review/lima/</guid>
      <description>프로그래머가 바닥에 떨어진 동전을 주웠더니 왜 행복한가요? 그 이유는 그의 &amp;ldquo;비트&amp;quot;를 찾았기 때문이죠! 프로그래머들은 이진수에서 &amp;ldquo;0&amp;quot;과 &amp;ldquo;1&amp;quot;을 &amp;ldquo;비트&amp;quot;라고 부르는데, 그 비트를 찾았으니 행복한 거죠! 자, 이제 다시 본론으로 돌아가서 앞서 언급한 대형 언어 모델의 내용을 다시 살펴 보겠습니다. 대형 언어 모델은 두 단계로 훈련됩니다. 첫 번째 단계는 비지도 사전 훈련 단계인데, 이때 모델은 원시 텍스트를 사용해 일반적인 언어 이해를 학습합니다. 그래서 대부분의 지식이 여기서 얻어지는거죠. 두 번째 단계는 큰 규모의 지시 튜닝과 강화 학습을 통해 모델을 최종 작업과 사용자 기호에 더 적합하게 조정하는 단계입니다.</description>
    </item>
    
    <item>
      <title>트랜스포머 모델의 개발</title>
      <link>https://happygrammer.github.io/ai/ml/transformers/</link>
      <pubDate>Tue, 20 Jun 2023 05:28:46 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/ml/transformers/</guid>
      <description>트랜스포머는 Attention 매커니즘이 적용된 멋진 딥러닝 모델이에요. 2017년에 구글이 발표한 &amp;ldquo;Attention is all you need&amp;rdquo; 논문에서 처음 소개되었죠. 이 모델은 RNN(1986)과 LSTM(1997) 같은 Recurrent 모델을 대체할 수 있는 대안으로 등장했어요. 트랜스포머는 자연어 처리와 같은 다양한 분야에서 성공을 거두었고, 그 인기는 계속해서 높아지고 있어요. GPT는 Transformer의 디코더 아키텍처를 활용하고 있고, BERT는 Transformer의 인코더 아키텍처를 활용하고 있습니다.
이 모델은 RNN 방식이 아닌 Attention 메커니즘을 더욱 효과적으로 활용하여 입력 시퀀스의 각 요소 간의 관계를 파악하고 중요한 정보에 집중할 수 있게 되었어요.</description>
    </item>
    
    <item>
      <title>모델 서빙 프레임워크</title>
      <link>https://happygrammer.github.io/mlops/serving/</link>
      <pubDate>Tue, 14 Mar 2023 23:16:52 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/serving/</guid>
      <description>MLOps에서 모델 서빙 MLOps에서 모델 서빙은 운영 중인 머신 러닝 모델을 사용자와 상호작용할 수 있도록 만들어주는 프로세스입니다. 이는 모델의 성능, 안정성, 신뢰성을 보장하고, 실시간으로 모델을 업데이트하고 모델의 예측 결과를 모니터링할 수 있도록 해줍니다. 서빙은 대체로 세가지 기능을 포함할 수 있어야합니다.
  사용자의 상호 작용 기능 : 모델 서빙은 사용자와의 상호작용 기능을 제공합니다. 이를 통해 모델이 실제 환경에서 사용되는 방식을 고려할 수 있습니다. 사용자의 요구사항에 따라 모델을 조정하고, 더 나은 성능을 위해 모델을 개선할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Voila 소개와 설치</title>
      <link>https://happygrammer.github.io/mlops/voila/</link>
      <pubDate>Tue, 24 Jan 2023 17:42:28 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/voila/</guid>
      <description>Voila는 Jupyter 노트북에서 생성된 대화형 웹 애플리케이션을 만드는 오픈 소스 도구입니다. Voila를 사용하면 Jupyter 노트북을 실행하면서 생성된 셀의 결과를 대화형 대시보드로 전환할 수 있습니다.
Jupyter 노트북은 데이터 분석 및 인공 지능 작업을 위한 인기있는 도구 중 하나입니다. 그러나 노트북의 코드와 결과는 주로 노트북 파일 자체에서만 볼 수 있습니다. 이는 작업을 공유하거나 다른 사람에게 결과를 시각적으로 보여줄 때 제한적일 수 있습니다.
Voila는 이러한 제한을 극복하기 위해 개발되었습니다. Jupyter 노트북을 실행하면 대화형 대시보드로 전환되며, 코드와 결과를 다른 사용자와 쉽게 공유할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Streamlit 소개와 설치</title>
      <link>https://happygrammer.github.io/mlops/streamlit/</link>
      <pubDate>Tue, 24 Jan 2023 17:14:01 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/streamlit/</guid>
      <description>Streamlit 소개 treamlit은 Python으로 데이터 시각화 및 웹 애플리케이션 개발을 간단하게 할 수 있게 해주는 라이브러리입니다. 특히, 데이터 과학자나 머신 러닝 엔지니어들이 머신 러닝 모델의 결과를 쉽게 공유하고 데모를 만들 수 있도록 해줍니다.
Streamlit은 다음과 같은 이점을 제공합니다.
 간편한 구현: Streamlit은 기본적인 웹 프레임워크와 비교하여 훨씬 적은 코드로 애플리케이션을 구현할 수 있습니다. 반응성: Streamlit은 실시간으로 변경 사항을 업데이트하고, 자동으로 새로고침합니다. 시각화: Streamlit은 matplotlib, bokeh, plotly 등과 같은 인기 있는 시각화 라이브러리와 함께 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>DVC 소개와 설치</title>
      <link>https://happygrammer.github.io/mlops/dvc/</link>
      <pubDate>Tue, 24 Jan 2023 15:02:39 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/dvc/</guid>
      <description>데이터 버전 관리 대용량 파일 버저닝을 위한 도구로 git-lfs, LakeFS, DVC, DeltaLake, dolthhub, Pachyderm, Neptune 등이 있습니다. 이중 DVC에 대해 알아 보도록 하겠습니다.
DVC 소개 DVC(data version control)는 데이터 과학자들을 위한 멋진 도구랍니다! 데이터와 모델을 버전 관리하는 데 사용됩니다. DVC를 사용하면 Git과 비슷한 방식으로 데이터셋의 버전을 추적하고, 원래대로 되돌리고, 변경사항을 쉽게 복원할 수 있습니다. Git에는 용량 제한이 있지만, DVC CLI를 이용하면 대용량 파일, 데이터셋 디렉토리, 머신러닝 모델 등을 작고 가벼운 메타 파일로 대체하여 데이터 버전 관리를 지원해주어 편리합니다.</description>
    </item>
    
    <item>
      <title>Airflow 설치</title>
      <link>https://happygrammer.github.io/mlops/airflow/</link>
      <pubDate>Tue, 24 Jan 2023 12:58:56 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/airflow/</guid>
      <description>Airflow는 데이터 파이프라인을 관리하고 스케줄링하기 위한 오픈소스 플랫폼입니다. Airflow는 일련의 작업(Task)을 DAG(Directed Acyclic Graph)로 구성하고, 각 작업이 완료될 때까지 기다렸다가 다음 작업을 실행할 수 있도록 설정할 수 있습니다.
Airflow의 가장 큰 장점 중 하나는 유연성입니다. 사용자는 Python으로 작성된 코드를 이용해 다양한 작업(Task)을 정의할 수 있습니다. 또한 Airflow는 다양한 플러그인을 지원하며, 다양한 데이터 소스와 연동이 가능합니다.
Airflow는 초보 사용자들도 쉽게 사용할 수 있도록 웹 인터페이스를 제공합니다. 이를 통해 DAG를 만들고, 실행 및 모니터링할 수 있습니다.</description>
    </item>
    
    <item>
      <title>MLFlow 소개</title>
      <link>https://happygrammer.github.io/mlops/mlflow/</link>
      <pubDate>Sun, 22 Jan 2023 06:10:22 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/mlflow/</guid>
      <description>MLflow는 머신 러닝 모델의 라이프 사이클을 관리하기 위한 오픈소스 플랫폼입니다. MLflow는 다음과 같은 세 가지 주요 기능을 제공합니다. MLFlow는 머신러닝 학습 주기 관리를 위한 오픈소스 플랫폼이다. MLFlow의 주요 기능은 아래와 같습니다.
 MLflow 트래킹(tracking) : MLflow Tracking은 실험 결과를 기록하여 실험간의 비교 지원을 할 수 있다. 기록 가능한 실험 요소로 실험시 사용한 하이퍼 파라메터나, 실험 결과 loss, auccracy 의 학습 과정에서 출력되는 주요 지표 들을 저장할 수 있다. 실험 결과들이 쌓이다 보면 각 실험들의 특징을 비교하기 어려울 수 있는데 이러한 경우는 는 tag 기능과 note 기능을 이용해 부가적인 정보를 기록함으로서 실험간의 비교시에 사용할 수 있도록 한다.</description>
    </item>
    
    <item>
      <title>TensorRT 설치</title>
      <link>https://happygrammer.github.io/ai/tensorrt/setup/</link>
      <pubDate>Sat, 14 Jan 2023 05:40:46 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorrt/setup/</guid>
      <description>TensorRT를 실행하려면 NVIDIA GPU 드라이버와 CUDA와 관련한 환경 설치를 먼저 진행하고 이후 NGC 컨테이너를 이용해 TensorRT를 실행할 수 있다.
출처 : Optimizing and Accelerating AI Inference with the TensorRT Container from NVIDIA NGC
TensorRT 환경 설치 TensorRT 설치를 위해서는 GPU가 있는 우분투 환경이 필요하다. 이어서 다음 순서대로 설치를 진행한다.
 NVIDIA GPU 드라이버를 설치 Cuda 설치  먼저 NVIDIA GPU 드라이버 설치를 진행한다. 권장 드라이버를 자동으로 설치하려면 아래 명령을 입력한다.</description>
    </item>
    
    <item>
      <title>TensorRT 소개</title>
      <link>https://happygrammer.github.io/ai/tensorrt/intro/</link>
      <pubDate>Sat, 14 Jan 2023 04:40:46 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorrt/intro/</guid>
      <description>TensorRT는 NVIDIA GPU상에서 모델의 추론 속도를 최적화해 주는 프레임워크이다.
TensorRT 최적화 방식 TensorRT는 GPU의 cuda 코어에서 시행된다. cuda는 GPU와 직접 통신하기 위한 API에 해당한다. (cudo 코어와 유사하게 Tensor 코어 방식이 있지만 구글 직원이 아니라면 TPU 배포는 좋은 선택지는 아닐 수 있다.) TensorRT는 다음 그림에 소개된 크게 6가지 방식으로 최적화를 수행한다.
위에서 몇가지만 살펴보면 Kernel Auto-tuning은 Cuda 드라이버에 맞춰 최적의 런타임을 생성할 수 있도록 한다. GPU 플랫폼 기반으로 최상의 레이어와 알고리즘, 최적의 배치 크기를 선택하는 방식이다.</description>
    </item>
    
    <item>
      <title>MLOps 오픈소스</title>
      <link>https://happygrammer.github.io/mlops/opensource/</link>
      <pubDate>Wed, 11 Jan 2023 06:02:52 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/opensource/</guid>
      <description>MLOps를 체계적으로 적용하기에 앞서 MLOps 도구를 도입할 필요가 있습니다. ML Ops의 도구 중 오픈소스는 기업이 도입하기에 유리한 방식입니다. 오픈소스 도입 전에 한가지 생각해 볼 점이 있습니다.
오픈소스 선택 MLOps에서 오픈소스를 사용하는 것은 매우 일반적인 방법입니다. 오픈소스는 머신 러닝 개발자들에게 매우 유용한 도구입니다. 다양한 머신 러닝 라이브러리와 프레임워크를 제공하며, 이를 사용하여 머신 러닝 모델을 쉽게 개발할 수 있습니다. 특히, 오픈소스를 사용하면 머신 러닝 모델의 개발 속도를 높일 수 있습니다. 또한, 오픈소스 커뮤니티에서는 다양한 문제들에 대한 해결책을 제공하며, 이를 활용하여 머신 러닝 모델을 개발할 수 있습니다.</description>
    </item>
    
    <item>
      <title>MLOps 플랫폼</title>
      <link>https://happygrammer.github.io/mlops/mlops-platform/</link>
      <pubDate>Tue, 10 Jan 2023 05:04:54 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/mlops-platform/</guid>
      <description>MLOps 플랫폼이란? MLOps 플랫폼 기술은 상용을 위한 기계학습 애플리케이션 배포 및 확장과 관련한 기술이다. 크게 세가지 관점의 기술 내용을 포함합니다.
 ML 모델 상태 관리 E2E 머신러닝 오케스트레이션 컨테이너 기술  ML 모델 상태 관리 기술은 머신러닝 모델의 생명 주기를 관리하고, 모델의 자동 배포 및 모델의 상태 정보를 관리하는 기술입니다. 이를 통해 모델의 생성 일자, 생성 주기, 모델의 성능 수치와 같은 모델의 특성 정보를 포함하여 모델을 모니터링하고, 모델의 사용량 및 처리량을 지속적으로 모니터링하고 제어할 수 있습니다.</description>
    </item>
    
    <item>
      <title>머신러닝 엔지니어가 알아야 할 MLOps</title>
      <link>https://happygrammer.github.io/mlops/mlops_essentials_for_ml_engineers/</link>
      <pubDate>Tue, 10 Jan 2023 05:04:54 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/mlops_essentials_for_ml_engineers/</guid>
      <description>안녕하세요, 개발자 여러분! 오늘은 머신러닝 엔지니어로서 꼭 알아야 할 MLOps에 대해 알아보겠습니다.
MLOps의 필요성 MLOps(Machine Learning Operations)는 머신러닝 모델의 개발, 배포, 모니터링 등을 자동화하고 관리하는 일련의 프로세스를 의미합니다. 머신러닝 모델을 개발하는 것만큼이나 중요한 것이 바로 이 MLOps입니다.
MLOps의 주요 구성 요소  데이터 수집 및 전처리 모델 학습 및 평가 모델 배포 및 서빙 모니터링 및 알림  데이터 수집 및 전처리 머신러닝 모델 개발에 있어 가장 중요한 부분 중 하나는 바로 데이터입니다.</description>
    </item>
    
    <item>
      <title>MLOps란 무엇인가?</title>
      <link>https://happygrammer.github.io/mlops/intro/</link>
      <pubDate>Tue, 10 Jan 2023 03:28:11 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/mlops/intro/</guid>
      <description>MLOps는 머신러닝과 소프트웨어 분야의 DevOps를 합친 합성어입니다. ML은 머싱러닝(Machine Learning)을 의미하며 Ops는 시스템 운영을 의미합니다. 이름 그대로 머신러닝 시스템 운영을 지원하는 체계입니다. ML 모델의 생성 배포에 필요한 운영 비용을 낮추고 효율적으로 ML 모델을 운영하기 위해 필요한 모범 사례 모음이기도 합니다. MLOps는 생명 주기의 각 과정을 자동화하는 데 과업들을 포함합니다. MLOps라는 용어에서 느껴지듯 ML 영역과 IT 의 역할을 합쳐 놓은 합성어이다. MLOps는 크게 ML 영역과 DEV영역과 OPS영역을 포괄하는 용어로 데이터 구축, 모델 개발 및 훈련, 모델 배포와 관련해 효율성과 생산성을 개선시키는데 초점이 있습니다.</description>
    </item>
    
    <item>
      <title>Mac에서 Kotlin 설치</title>
      <link>https://happygrammer.github.io/dev/language/kotlin/setup/</link>
      <pubDate>Mon, 09 Jan 2023 03:39:17 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/kotlin/setup/</guid>
      <description>kotlin은 IntelliJ IDEA 개발사로 유명한 JetBrains에서 2011년에 공개한 오픈 소스 프로그래밍 언어이다. Java와 유사하며 Java에 비해 조금 더 간결한 문법을 사용한다는 특징이 있다. Java와 100% 상호 호환이 가능하다. Android의 공식 언어로 채택된 언어이기도 하다. 코틀린 구성에 앞서 java를 설치하도록 한다. (환경 MacOS)
brew install openjdk@17 설치가 완료되면 설치된 openjdk 경로를 bash_profile에 반영해준다.
echo &#39;export PATH=&amp;quot;/usr/local/opt/openjdk@17/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; /Users/smarthome/.bash_profile source ~/.bash_profile 어어서 java버전을 확인한다.
$ java -version openjdk version &amp;quot;17.0.5&amp;quot; 2022-10-18 OpenJDK Runtime Environment Homebrew (build 17.</description>
    </item>
    
    <item>
      <title>딥러닝 GPU 성능 비교</title>
      <link>https://happygrammer.github.io/dev/gpu/</link>
      <pubDate>Wed, 21 Sep 2022 06:34:02 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/gpu/</guid>
      <description>GPU와 CPU의 차이점 GPU는 그래픽 처리에서 사용했다. 최근 GPU는 그래픽 처리 뿐 아니라 병렬 수치 연산에도 이용되고 있다. 딥러닝은 대량의 곱셈, 큰 행렬의 내적 등을 수행하는데 GPU 컴퓨팅을 이용하면 연속을 고속화하여 처리할 수 있다. CPU(CPU, Central Processing Unit)와 GPU(GPU, Grapical Processing Unit)는 공통적으로 마이크로프로세서이다. 둘다 데이터를 처리한다는 공통점이 있다. 그런데 이 둘은 아키텍처가 다르고 용도와 목적이 다르다. CPU는 코어 성능이 중요한 워크 로드에 적합하다. CPU 내부의 ALU(arithmetic Logic Unit)는 순차적인(sequential) 방식으로 명령어를 하나씩 처리하는 특징이 있다.</description>
    </item>
    
    <item>
      <title>시스템 사고로 장애를 방지하세요</title>
      <link>https://happygrammer.github.io/insights/system-thinking/</link>
      <pubDate>Fri, 16 Sep 2022 06:58:08 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/system-thinking/</guid>
      <description>안녕하세요, 개발자 여러분! 오늘은 시스템 장애 발생 시 효과적으로 대응하기 위한 전략에 대해 알아보겠습니다.
시스템 장애의 불가피성 아무리 단단한 시스템이라 하더라도 서버의 장애나 성능 이슈에 있어서 자유로울 수 없습니다. 시스템 운영자는 장애가 발생했을 때 당황하기 쉽지만, 문제 원인을 빠르게 분석하고 처리할 수 있는 방법과 절차가 필요합니다.
APM을 활용한 모니터링과 트러블슈팅 APM(Application Performance Management)와 같은 시스템을 이용해 모니터링과 트러블슈팅을 위한 시스템의 각종 정보들을 평소에 확인하여 대비해야 합니다. APM은 애플리케이션의 성능을 실시간으로 모니터링하고, 문제 발생 시 신속하게 대응할 수 있도록 도와줍니다.</description>
    </item>
    
    <item>
      <title>간결하게 코딩하기</title>
      <link>https://happygrammer.github.io/insights/coding-concisely/</link>
      <pubDate>Fri, 09 Sep 2022 22:01:15 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/coding-concisely/</guid>
      <description>코드를 작성할때 간결함이란 그저 짧게만 작성한 코드를 의미하지 않는다. 꼭 필요한 코드를 충분히 잘 작성하여 목적에 맞는 기능이 동작해야 한다. 코드 작성 시의 간결함은 그저 잘 동작하는 코드만을 작성하는 것을 의미하지는 않는다. 불필요한 코드 작성을 제거하여 목적지가 분명한 방향성을 포함한다.
간결한 코드는 경험에서 나온다. 가볍고 간결한 코드는 정확한 이해 없이 그저 짧게 작성한 코드를 의미한다. 깊이있고 간결한 코드는 관련 지식을 바탕으로 간단명료하게 작성된 코드를 의미한다. 간결한 코드를 잘 작성하기 위해 코드를 깊숙이 파고들어가 분석하고 이해해야 한다.</description>
    </item>
    
    <item>
      <title>못난 코드 알아보기</title>
      <link>https://happygrammer.github.io/insights/find-out-the-bad-code/</link>
      <pubDate>Thu, 08 Sep 2022 13:33:15 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/find-out-the-bad-code/</guid>
      <description>훌륭한 코드를 작성하고 싶다면 코드를 잘 쓰려고 노력하는데 그치지 말고 잘못 작성된 코드를 알아보는 감각을 키우는 노력이 필요하다. 바이올린과 같은 현악기는 연주자가 줄을 팅겨 보면서 음높이를 조절한다. 음높이를 조절할때는 음감을 이용하여 조율한다. 악보를 외우고 숙달하면 숙달된 바이올리니스트의 시늉을 하면서 한두 곡 정도는 연주가 가능할 수 있지만 모든 연주를 그렇게 할수는 없다. 올바른 코드를 작성하려면 잘못 작성된 코드를 먼저 알아보는 감각이 필요하다.
어떻게 하면 못난 코드를 알아볼까? 쉽고 간단한 방법이 있다. 셀프 코드 리뷰를 진행해 보는 것이다.</description>
    </item>
    
    <item>
      <title>클린 아키텍처 재해석</title>
      <link>https://happygrammer.github.io/dev/clean-architecture/</link>
      <pubDate>Mon, 13 Jun 2022 00:18:44 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/clean-architecture/</guid>
      <description>좋은 아키텍처란 시스템 생명 주기(개발, 유지보수, 배포, 운영)를 쉽게 지원할 수 있는 아키텍처이다.
 </description>
    </item>
    
    <item>
      <title>깃 저장소의 커밋 히스토리 초기화</title>
      <link>https://happygrammer.github.io/dev/initialize-git-repository/</link>
      <pubDate>Wed, 01 Dec 2021 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/initialize-git-repository/</guid>
      <description>깃 저장소를 마지막 변경 파일만 남기고 커밋 이력을 초기화하고 싶은 경우가 있다. 깃 저장소 커밋 이력을 초기화 하는 방법에 대해서 살펴보자. 작업 과정을 명확히 공유하기 위해 실재 입력한 명령어와 반영된 결과 그리고 실재 작업된 결과를 첨부 하였다. 다음과 같은 순서로 진행할 예정이다.
 원격 저장소의 파일을 지운다. 브랜치 작업을 이용한 커밋 히스토리 삭제 신규 파일 commit  파일을 삭제해 빈 저장소로 만들기 커밋 이력을 초기화하려면 temp 브랜치를 추가(추가한 temp 브랜치에는 커밋 히스토리가 없음)하고 커밋 히스토리가 있는 master 브랜치를 삭제한 후, temp 브랜치를 master 브랜치로 이름을 변경하는 것으로 가능하다.</description>
    </item>
    
    <item>
      <title>아인슈타인의 문제 해결법</title>
      <link>https://happygrammer.github.io/insights/break_the_rules/</link>
      <pubDate>Wed, 24 Nov 2021 22:14:45 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/break_the_rules/</guid>
      <description>필자는 아인슈타인에 대해 관심이 많다. 인류가 알지 못했던 물리학의 비밀을 밝혀준 천재여서 이기도 하지만, 그의 인생 철학들이 많이 공감되고, 필자가 추구하는 방향이기도 하다.
같은 일을 반복하면서 다른 결과가 나오기를 기대하는 것보다더 확실한 정신병 증세는 없다. 아인슈타인은 무한한 상상력으로 자유로운 사고가 가능했다. 그의 자유로운 사고의 원천은 순응하지 않는 태도였다.
나는 학습을 방해하는 유일한 훼방꾼은 나의 교육이다. 교육을 받고 자란 우리들은 사회화 과정을 겪어 법칙에 복종하도록 교육을 받았다. 교육은 권위에 복종하는 것 가르친다.</description>
    </item>
    
    <item>
      <title>T5 모델 소개 및 실습</title>
      <link>https://happygrammer.github.io/nlp/t5/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/t5/</guid>
      <description>사전 훈련된 모델이 다운스트림 태스크로의 전이학습은 자연어처리의 강력한 기술로 부상했다. 전이학습 모델 중 T5모델에 살펴보고자 한다.
T5 모델 소개 T5[1]는 모든 텍스트 기반 언어 문제를 텍스트 대 텍스트 형식으로 변환하는 통합 프레임워크(unified framework)를 도입했다. 이 연구는 C4(Colossal Clean Crawled Corpus) 코퍼스를 결합하여, 요약, 질의응답, 분류 및 기타 문제에 대해서 최신 SOTA(state-of-the-art)를 달성했다.
사전 훈련된 모델이 다운스트림 태스크로의 전이학습은 자연어처리의 강력한 기술로 부상했다. T5는 모든 텍스트 기반 언어 문제를 텍스트 대 텍스트 형식으로 변환하는 통합 프레임워크(unified framework)를 도입했다.</description>
    </item>
    
    <item>
      <title>Word2vec를 이용한 임베딩</title>
      <link>https://happygrammer.github.io/nlp/word2vec/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/word2vec/</guid>
      <description>Word2vec은 워드 고품질의 워드 벡터를 생성하는 임베딩 태스크에 사용할 수 있는 모델입니다. 구글의 Tomas Mikolov이 2013년에 논문으로 발표했습니다. 이 논문에서 소개하는 단어 예측 모델로 크게 CBOW와 Skip-gram을 소개합니다. CBOW는 Context 정보를 활용해 현재 단어를 예측 하는 모델이라면 Skip-gram은 현재 워드 주변의 단어를 예측하는 모델입니다. Word2vec을 실행하면 입력으로 대규모 텍스트 코퍼스를 수백 차원의 벡터 스페이스(vector space)로 만듭니다. 기존 LSA(latent semantic analysis)에 비해 여러 장점이 있습니다.
 계산 비용이 적습니다. 정확도(accuracy)가 개선 됐습니다.</description>
    </item>
    
    <item>
      <title>서브워드 모델</title>
      <link>https://happygrammer.github.io/nlp/sub-words-model/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/sub-words-model/</guid>
      <description>서브워드 알고리즘 서브워드와 관련한 유명한 알고리즘은 다음 네가지가 있습니다.
 Byte Pair Encoding (BPE) WordPiece Unigram Language Model SentencePiece  BPE BPE(Byte Pair Encoding)는 서브 워드 사전 구축에 사용되는 알고리즘은 다음 그림과 같습니다.
WordPiece 워드 피스(WordPiece)는 일본어와 한국어의 음성 문제를 해결 하기 위해 나온 모델입니다.(2012년) 워드 피스는 BPE와 유사하며 차이점은 새로운 서브 워드를 만들 수 있다는 점입니다.
Unigram 모델 쿠도 연구자가 소개한 모델입니다. 이 모델이 가정 하는 것은 모든 서브워드는 독립적인 이며 서브 워드 시퀀스이 나타날 확률은 서브 워드 확률에 결정된다는 점입니다.</description>
    </item>
    
    <item>
      <title>시맨틱 롤 레이블링 소개</title>
      <link>https://happygrammer.github.io/nlp/srl/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/srl/</guid>
      <description>시맨틱 롤 레이블링은 NLP 처리의 과정 중 하나이다. 시맨틱 롤 레이블링은 다른 말로 shallow semantic parsing, slot-filling, 의미역 결정과 같은 말로도 불린다. NLU를 하기 전의 가장 기본적인 접근은 형태소 분석과 구문 분석이다. 기본적인 처리가 끝나면 시맨틱 롤 레이블을 수행할 수 있다.
시맨틱 롤 레이블링 역사 SRL은 필모어(Charles J. Fillmore) 연구자에 의해 제안된 방법이다. 초창기 연구에서는 predicate에 해당하는 역할을 찾으려는 시도들이 있었다. 이후 프레임 넷을 이용한 SRL이라는 방식으로 확장이 되었다.
시맨틱 롤의 종류 시맨틱 롤(role)이라는 것은 우리 말로 의미역(semantic role)이라고 볼 수 있다.</description>
    </item>
    
    <item>
      <title>텍스트 전처리</title>
      <link>https://happygrammer.github.io/nlp/text-preprocessing/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/text-preprocessing/</guid>
      <description>텍스트 전처리(text preprocessing)은 입력 데이터셋에 섞여 있는 불필요한 노이즈를 제거하거나 데이터를 일관성있게 만드는 정규화 과정을 포함한다. 전처리는 크게 두 단계의 작업을 수행한다.
 노이즈 제거 텍스트 정규화  노이즈 제거(Noise removal)는 불필요한 태그 제거, 특수 문자 제거, 구두점 제거, 공백 제거등 실질 데이터와 무관한 문자를 삭제해 단어나 문장 인식을 명확히 할 수 있도록 만드는 전 처리 단계다. 텍스트 정규화(Text normalization)는 계산량을 줄이기 위한 처리다. 텀 매트릭스의 차원 축소(dimensionally reduction)을 축소해 계산을 빠르고 효율적이도록 한다.</description>
    </item>
    
    <item>
      <title>토크나이저의 종류와 비교</title>
      <link>https://happygrammer.github.io/nlp/tokenizer_wordpiece_vs_sentencepiece/</link>
      <pubDate>Sun, 21 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/tokenizer_wordpiece_vs_sentencepiece/</guid>
      <description>안녕하세요, 개발자 여러분! 오늘은 자연어 처리에서 많이 사용되는 두 가지 토크나이저인 워드피스(WordPiece)와 센텐스피스(SentencePiece)에 대해 알아보고, 이들의 공통점과 차이점을 비교해 보겠습니다.
1. 토크나이저 알고리즘의 종류 워드피스(WordPiece)와 센텐스피스(SentencePiece) 외에도 다양한 토크나이저(Tokenizer)들이 있습니다. 각 토크나이저마다 고유한 특징과 장단점이 있으며, 최근에는 언어 모델의 성능 향상을 위해 새로운 토크나이저들이 제안되고 있습니다. 아래에서 몇 가지 토크나이저와 그 특징에 대해 설명하겠습니다.
1.1 Byte Pair Encoding (BPE):  BPE는 빈도수가 높은 바이트 쌍을 병합하여 단어를 분리하는 방식입니다. 어휘 크기를 제한할 수 있으며, 미등록 단어(OOV, Out-of-Vocabulary)에 대한 처리가 가능합니다.</description>
    </item>
    
    <item>
      <title>n-gram 모델</title>
      <link>https://happygrammer.github.io/nlp/n-gram-model/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/n-gram-model/</guid>
      <description>n-gram 모델 n-gram 모델은 자연어 처리, 정보 검색 등에서 활용이 되는 시퀀스 데이터 표현 방식입니다. 자연어 처리에서는 문서 또는 문장을 벡터로 변환해 자연어 처리의 여러 응용 분야에 활용할 수 있도록 합니다. 예를 들어 다음 단어를 예측해야 하는 오타 교정과 같은 분야에 활용될 수 있습니다. 정보 검색에서는 문서에 나타난 단어들의 분포들을 고려해 문서 간의 유사도 계산해 문서 분류(document classification)에 활용합니다. ngram에서 n은 연속된 단어의 개수를 의미합니다. 여기서 각 단어는 토큰(token)이라 하며 토큰 개수(n)에 따라 다음과 같이 부릅니다.</description>
    </item>
    
    <item>
      <title>NLTK를 이용한 자연어 처리</title>
      <link>https://happygrammer.github.io/nlp/nltk/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/nltk/</guid>
      <description>NLTK(Natural Language Toolkit)는 언어 처리 기능을 제공하는 파이썬 라이브러리입니다. 손쉽게 이용할 수 있도록 모듈 형식으로 제공하고 있습니다. 이러한 모듈의 범주로 분류 토큰화(tokenization), 스테밍(stemming)와 같은 언어 전처리 모듈 부터 구문분석(parsing)과 같은 언어 분석, 클러스터링, 감정 분석(sentiment analysis), 태깅(tagging)과 같은 분석 모듈 시맨틱 추론(semantic reasoning)과 같이 보다 고차원 적인 추론 모듈도 제공하고 있습니다. 각 모듈에서 사용하는 알고리즘은 최소 2개 이상의 알고리즘을 제공하고 있어, 사용자가 원하는 알고리즘을 폭넓게 사용할 수 있도록 돕습니다. 예를 들어 분류 알고리즘의 경우 SVMs, 나이브 베이즈(Naive Bayes), 로지스틱 회귀(logistic regression)와 결정 트리(decision trees)를 제공하고 있고 이들 중 하나를 선택해 분류 알고리즘을 적용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>언어 모델</title>
      <link>https://happygrammer.github.io/nlp/language-models/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/language-models/</guid>
      <description>언어 모델(language model)은 단어 시퀀스(word sequence)를 이용한 확률 모델입니다. 언어 모델은 기계 번역, 음성 인식, 오타 교정(spell correction), 손글씨 인식(handwriting recognition), 문서 요약, 질의 응답 생성 등과 같이 최종 출력인 단어 시퀀스를 예측하는 태스크에 사용됩니다.
확률 언어 모델 확률 언어 모델(probabilistic langugage model)은 하나의 단어(w) 앞에 나온 n개의 단어 시퀀스(word sequence)을 고려해 다음에 나올 단어를 예측하는 확률 모델입니다. n개의 단어가 연속해서 나는 단어 시퀀스의 확률 P(w1,w2,w3,&amp;hellip;,wn)는 다음과 같습니다.
P(W)=P(w1,w2,w3,...,wn) 즉, n개의 단어를 하나의 시퀀스로 보고 단어 시퀀스들의 결합 확률을 계산해 언어 모델을 만듭니다.</description>
    </item>
    
    <item>
      <title>언어 모델에 대한 이해</title>
      <link>https://happygrammer.github.io/nlp/lm/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/lm/</guid>
      <description>언어모델(Language Model)은 자연어처리 분야에서 주인공이죠. 대량의 텍스트 데이터에 대한 문장의 구조, 의미, 문맥을 완벽히 소화해내는 달인이라고 생각해요. 언어 모델은 새로운 문장을 생성하는 능력이 뛰어난데요, 가끔은 언어모델에게 배울게 많다는 생각이 들어요. 그래서 어떤 문장을 내뱉을지, 기대감이 느껴지기도 해요. 예를 들어, 텍스트 입력으로 &#39;나는 점심에 식사를 하러 ____ ____&#39;라는 입력이 들어왔을 때, 언어 모델은 빈칸에 알맞은 우주로 날아갔다&#39; 와 같은 단어를 예측해줘요! 그래서 자동 요약, 기계 번역, 검색 엔진, 문장 완성 등 다양한 분야에서 활용되고 있답니다.</description>
    </item>
    
    <item>
      <title>자연어 처리를 위한 정규식</title>
      <link>https://happygrammer.github.io/nlp/regular-expressions/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/regular-expressions/</guid>
      <description>정규식(regular expressions)은 프로그래밍 언어 내장된 문자열 처리를 위한 언어입니다. 패턴을 기반으로 문자열에 대한 검색, 삭제, 치환 기능을 수행할 수 있습니다. 예를 들어 이메일 주소, 전화번호, 우편번호 등과 같이 널리 사용되는 형식의 패턴을 추출 하거나 문자열 분리, 삭제, 치환 등의 텍스트 정제에 사용할 수 있습니다.
정규식 메타 문자열 메타 문자열은 정규식에서 문자열 매치 할 때 사용하는 문자열입니다. 다음과 같은 문자열이 있습니다.
. ^ $ * + ? { } [ ] \ | ( ) 위에서 열거한 메타 문자는 정규식에서 특별한 의미가 있습니다.</description>
    </item>
    
    <item>
      <title>자연어처리 라이브러리 소개</title>
      <link>https://happygrammer.github.io/nlp/open-source/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/open-source/</guid>
      <description>자연어처리 모듈을 처음 부터 모두 개발하는 것은 쉽지 않습니다. 따라서 필요로 하는 자언어 처리 알고리즘이 이미 구현되어 있다면 효율적인 진행을 위해 공개된 자연어처리 라이브러리를 적절히 이용하는 것이 좋습니다. 오픈소스로 공개된 자연어처리 라이브러리는 그 수가 많습니다. 본문에서는 주요 자연어처리 라이브러리를 소개하며 어떤 점을 활용하면 좋을지를 소개 하겠습니다.
자연어처리 툴킷(NLTK) NLTK(Natural Language Toolkit)는 언어 처리 기능을 제공하는 파이썬 라이브러리입니다. 손쉽게 이용할 수 있도록 모듈 형식으로 제공하고 있습니다. 이러한 모듈의 범주로 분류 토큰화(tokenization), 스테밍(stemming)와 같은 언어 전처리 모듈 부터 구문분석(parsing)과 같은 언어 분석, 클러스터링, 감정 분석(sentiment analysis), 태깅(tagging)과 같은 분석 모듈 시맨틱 추론(semantic reasoning)과 같이 보다 고차원 적인 추론 모듈도 제공하고 있습니다.</description>
    </item>
    
    <item>
      <title>품사와 품사 태그셋 소개</title>
      <link>https://happygrammer.github.io/nlp/postag-set/</link>
      <pubDate>Sat, 20 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/postag-set/</guid>
      <description>POS tagging(part-of-speech tagging)은 형태소 분석 결과 분류된 품사를 태깅하는 작업을 의미한다. 여기서 품사는 단어의 공통 성질을 갈래 지어 놓은 이름이다. 태깅시 사용하는 품사에 대응하는 약속은 품사 태그(POS Tag : part-of-speech tag)라 하며 이들 품사 태그의 모음을 품사 태그 셋(tag set)이라고 한다. 품사 부착 말뭉치(corpus)는 품사 태그가 부착된 말뭉치를 의미한다. 고품질의 품사 부착 말뭉치의 규모가 커지면 언어 연구 진행이 용이해진다. 이 문서에는 품사 태그셋을 소개하기에 앞서 한국어와 영어의 품사를 소개하고, 영어의 품사 태그셋과 한국어의 품사 태그셋(POS Tag Set)을 소개한다.</description>
    </item>
    
    <item>
      <title>자연어 처리 과정</title>
      <link>https://happygrammer.github.io/nlp/intro-nlp-2/</link>
      <pubDate>Fri, 19 Nov 2021 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/intro-nlp-2/</guid>
      <description>컴퓨터가 사람의 언어를 이해하기 위해 일반적으로 다음과 같은 언어 처리 과정을 거칩니다.
텍스트 입력 → 형태소 분석 → 구문 분석 → 의미 분석 → 화용 분석 → 분석 결과 출력 형태소 분석(morphological analysis)은 자연어의 최소 의미인 형태소를 식별하는 언어 처리 과정입니다. 구문 분석(syntax analysis)은 주어, 동사, 목적어등의 문장성분을 판별해 문장성분에 따른 문장 구조를 분석하는 과정입니다. 문장성분을 분석하기 위해 구문 분석기(parser)를 이용해 구문(構文) 분석을 수행하여 구문 트리(syntax tree)또는 파스 트리(parse tree)를 만듭니다.</description>
    </item>
    
    <item>
      <title>휴리스틱 가이드라인</title>
      <link>https://happygrammer.github.io/dev/heuristic/</link>
      <pubDate>Tue, 02 Nov 2021 23:37:11 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/heuristic/</guid>
      <description>휴리스틱 가이드라인은 직관적으로 판단할때 사용할 수 있는 UX적용 요소를 포함하고 있다. 웹에서 쓰이는 대표적인 휴리스틱 가이드라인으로는 제이콥 닐슨이 제시한 10가지 가이드라인이 있다.
1. 가시성 시스템은 사용자에게 시스템 상태를 적절한 시기에 인지하기 좋은 형태로 전달함
2. 익숙함 시스템은 사용자가 현실 세계에서 익숙한 단어를 사용함
3. 자유성 사용자가 실수로 특정 기능을 선택하더라도 복구할 수 있는 제어 방법을 제공함
4. 일관성 시스템에 사용하는 용어는 일관성 있게 사용
5. 예방 에러 예방을 위해 에러 메시지가 어떤 의미인지 사용자에게 전달</description>
    </item>
    
    <item>
      <title>합의의 기술</title>
      <link>https://happygrammer.github.io/insights/agreement/</link>
      <pubDate>Sat, 23 Oct 2021 12:59:12 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/agreement/</guid>
      <description>청주시 노인 전문 병원의 경우 100억 투자 후 만든 신축병원이었지만 노사 갈등으로 5개월 만에 폐업으로 인해, 청주 시민들은 의료서비스를 못 받게 되는 간접 손해가 발생했다. 갈등이 늘어날수록 손실 비용이 증간한다. 즉, 사회적 비용이 증가하는 것이다. 갈등이 해결되지 않는다는 것은 각자의 목표만 있고 평행선을 달리고 있다는 것을 의미한다. 이런 경우 변화에 대한 사회적 합의를 위해 토론이 필요하다.
시민합의회의(Consensus Conference)에 참석한 시민들 과거에 하르츠 개혁은 노동개혁위원회 15명을 구성하여 합의된 내용은 쟁점화하지 않는다는 원칙을 세웠다.</description>
    </item>
    
    <item>
      <title>상용 AI 시스템 설계</title>
      <link>https://happygrammer.github.io/ai/ai-systems/about/</link>
      <pubDate>Sun, 26 Sep 2021 09:34:35 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/ai-systems/about/</guid>
      <description>AI 시스템은 머신러닝 모델의 생성에 필요한 서버 환경을 바탕으로 데이터 관리, 모델 관리, API 인터페이스를 제공하는 시스템이다. AI 시스템이 안정적인 서비스를 제공하려면 신뢰성과 확장성을 바탕으로 한다.
하나의 AI 시스템은 추천 모델, 언어 모델, 음성 모델 등 다양한 모델들을 운영한다. 이것은 서비스 관점에 따라서 상이한 모델을 호출해서 사용하기 때문이다. 여러 모델을 하나로 합치려는 방식도 있지만, 이는 현실적으로 어려운 점이 있다. 머신러닝 모델을 실재 상용에 운영하기 위해서는 기본적인 규모 있는 데이터를 관리할 수 있어야 하고, 이를 바탕으로 머신러닝 모델을 생성할 수 있어야 한다.</description>
    </item>
    
    <item>
      <title>알고리즘, 문제해결 기법</title>
      <link>https://happygrammer.github.io/dev/algorithm/why/</link>
      <pubDate>Thu, 16 Sep 2021 16:52:27 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/algorithm/why/</guid>
      <description>알고리즘을 공부하는 목적은 무엇일까? 알고리즘을 답습(踏襲)해 문제해결 기법을 훈련하는 것이다. 알고리즘을 자신의 언어로 풀어서 체계적으로 생각하는 훈련을 수 있을 것이다. 알고리즘은 귀납적 접근을 기반으로 한다.
귀납적인 접근 알고리즘 학습을 통해 귀납적 사고를 훈련할 수 있다. 귀납적(inductive)이라는 말은 본래 수학 분야에서 왔다. 귀납적이라는 말의 사전적 정의는 개별적인 특수한 사실이나 원리로부터 공통적을 추려내 일반적이고 보편적인 명제 및 법칙을 유도해 내는 일이다.
귀납적 사고는 도미노 효과와 비슷한 방식으로 작동한다. 첫번째 블럭이 넘어지면 두번째 블럭이 넘어지듯이, 전제가 성립하면 결론도 성립하게 된다.</description>
    </item>
    
    <item>
      <title>대화형 에이전트</title>
      <link>https://happygrammer.github.io/nlp/dialog-system-chatbots/</link>
      <pubDate>Mon, 23 Aug 2021 00:58:02 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/dialog-system-chatbots/</guid>
      <description>사람이 컴퓨터와 대화를 하는 시대가 열렸다. 가상 비서(virtual assistant)를 통해 음성으로 영화를 예매하거나, 음성으로 음악 재생을 요청하는 등의 일을 처리할 수 있게 되었다. 가상 비서의 예로 시리, 알렉사, 구글 홈, 기가지니, SKT 누구 등이 있다. 가상 비서는 대화 알고리즘을 바탕으로 구현 된다. 대화 알고리즘을 포함해 대화 처리를 수행하는 시스템을 대화형 에이전트(conversational agents) 또는 대화 시스템(dialog system)이라고 부른다.
대화 에이전트들은 영화 예매를 수행하거나, 주식 조회하거나, 근처 맛집을 찾는 등과 같이 미리 설계된 내용에 대한 특정 작업을 수행하도록 미리 설계 되어 있다.</description>
    </item>
    
    <item>
      <title>비즈니스 라이팅 방법</title>
      <link>https://happygrammer.github.io/insights/business-writing/</link>
      <pubDate>Sat, 21 Aug 2021 20:08:07 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/business-writing/</guid>
      <description>쉬운 비즈니스 라이팅을 위한 5가지 방법
 쉬운 용어  전문 용어 대신 듣는이가 이해할 수 있는 쉬운 용어를 사용한다.  (예) &amp;lsquo;리팩토링&amp;rsquo; → &amp;lsquo;프로그램 코드 개선&amp;rsquo;, (예) &amp;lsquo;ER&amp;rsquo; → &amp;lsquo;응급실&amp;rsquo; (예) &amp;lsquo;프로시저&amp;rsquo; → &amp;lsquo;시술&amp;rsquo;     부연 설명  단순 정보만 전달하지 말고 부연 설명을 곁들인다. 어려운 내용은 결론만 말하지 말고, 결론의 배경을 차례대로 설명한다.   명확하게  적절한 슬라이드 제목, 폰트, 적절히 사용하고 중요한 단어에 볼드체를 사용한다.</description>
    </item>
    
    <item>
      <title>클로저란 무엇인가?</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/closures/</link>
      <pubDate>Sun, 01 Aug 2021 08:45:28 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/closures/</guid>
      <description>내부 함수와 외부 함수 자바스크립트는 기본적으로 함수 내부에 내부 함수 선언을 지원한다. 이렇게 내부에 함수를 중복해서 중첩(nested) 형태로 선언이 가능하며, 외부 함수는 내부 함수를 포함하는 형태로 선언이 가능하다.
function init() { // 외부 함수 function message() { // 내부 함수 return &amp;quot;happyg&amp;quot;; // lexical scope에 선언된 로컬 변수인 name 응답 가능 } return message(); } document.write(init()); // 외부에서는 내부 함수가 message인지 알 수 없다. 외부 함수인 init이 내부 함수인 message 를 포함한 선언 형태이다.</description>
    </item>
    
    <item>
      <title>아마존 웹 서비스 개요</title>
      <link>https://happygrammer.github.io/dev/cloud/amazon-web-service-overview/</link>
      <pubDate>Sat, 17 Jul 2021 15:11:42 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/amazon-web-service-overview/</guid>
      <description>AWS Ovewview  AWS 리전 한국에는 데이터 센터가 4개로 구성되어있고, 이를 가용 영역이라 부름(서울 리전인 경우) CDN(콘텐츠 전송 네트워크) cloud front 제공 AWS 이점 - 보안, 가용성, 성능, 확장성, 유연성  VPC(Virtual Private Computing)   사용자가 정의한 네트워크 공간 제공
  NAT Gateway는 내부 사설 IP(Private IP) 간의 Gate Way 역할., NAT Gateway에 EIP(Elastic IP)를 붙여서 외부 IP로 사용.
  InBound/OutBound
  Web Server는 443(port)에 대해 Any Open으로 제공</description>
    </item>
    
    <item>
      <title>스코프 크리프 방지법</title>
      <link>https://happygrammer.github.io/insights/scope-creep/</link>
      <pubDate>Sun, 30 May 2021 09:46:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/scope-creep/</guid>
      <description>어느 프로젝트나 &amp;lsquo;품질&amp;rsquo;, &amp;lsquo;비용&amp;rsquo;, &amp;lsquo;시간&#39;라는 요소가 프로젝트 성공에 영향을 미친다. 이러한 요소들간의 관계를 보여주는 것이 스코프 삼각형(Scope Triangle)이다. 스코프 삼각형은 프로젝트의 성공 요인들에 대한 트레이드 오프 관계가 존재함을 나타낸다.
스코프 삼각형에서 시간은 프로젝트가 성공하기 위해 필요한 최소한의 가용한 시간이고, 비용은 프로젝트에서 프로젝트를 성공적으로 완수하기 위해 필요한 자원의 양을 나타낸다. 품질은 프로젝트가 성공하기 위해 달성해야 하는 목표 또는 기능 범위에 해당한다. 프로젝트를 성공적으로 수행하기 위해 세 요소는 적절히 조정이 될 필요가 있다.</description>
    </item>
    
    <item>
      <title>장애 허용 시스템</title>
      <link>https://happygrammer.github.io/dev/cloud/distributed-system/fault-tolerance/</link>
      <pubDate>Wed, 19 May 2021 16:10:27 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/distributed-system/fault-tolerance/</guid>
      <description>분산 시스템이 있을때 하나의 노드에서 에러가 나더라도 전체 네트워크에 영향을 미쳐서는 안된다. 분산시스템을 구축하는 이유는 빠른 계산처리와 안전성을 도모하기 위해서이다. 빠른 계산 처리라 함은 하나의 컴퓨터로 처리할수 있는 계산량의 한계가 정해저 있어 병렬 처리를 하기 위함 이다. 안정성은 하나의 Node에 Fault가 나더라도 예비 Node가 있어 Node가 Fault가 되는것에 대해 대비해야 한다.
장애 허용 시스템 장애 허용 시스템(Fault Tolerance System)은 하나의 컴포넌트가 fault가 발생해도 시스템 운영에 영향을 주지 않도록 설계된 시스템이다. 다음과 같은 점을 고려할 수 있다.</description>
    </item>
    
    <item>
      <title>분산처리 시스템 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/distributed-system/about/</link>
      <pubDate>Tue, 18 May 2021 23:47:08 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/distributed-system/about/</guid>
      <description>분산처리 시스템은 여러 시스템 간의 동작을 일관성 있게 처리해 마치 하나의 프로세스가 하는 처리하는 것처럼 수행하는 시스템이다. 하나의 서버에 결집되어 있는 서버의 자원과 기능을 여러 서버에 분산 시켜 상호 협력함으로써 처리 성능과 신뢰성을 높이는 데 목적이 있다.
분산 시스템의 고전적인 문제 Failure Detection, Peer to Peer Systems, Key value store, sensor networks등이 으며, 동기화, 보안 관련 문제가 있다.
 동기화(Synchronization)은 실재 시간 근거로 싱크를 맞추는것이며, 분산 환경에서 싱크를 맞추는 것은 쉽지 않다.</description>
    </item>
    
    <item>
      <title>AI 관련 컨퍼런스와 출판물</title>
      <link>https://happygrammer.github.io/ai/papers/conference/</link>
      <pubDate>Sun, 25 Apr 2021 17:18:56 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/papers/conference/</guid>
      <description>1. AI 관련 컨퍼런스 AI 관련 상위 컨퍼런스는 다음과 같습니다.
  IR/Web: SIGIR, WWW, CIKM, WSDM
  NLP: ACL, EMNLP, NAACL
  ML/DM: ICML, NIPS, KDD, AAAI, IJCAI, ICLR
  2. AI 관련 출판물 AI 분야 출판물 AI 분야 출판물 순위는 다음과 같습니다.(2021년 4월 25일 기준)
   출판물 h5-index h5-median      1. International Conference on Learning Representations 203 359   2.</description>
    </item>
    
    <item>
      <title>코드 리뷰 어떻게 할 것인가</title>
      <link>https://happygrammer.github.io/dev/code-review/</link>
      <pubDate>Fri, 09 Apr 2021 23:29:22 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/code-review/</guid>
      <description>코드리뷰는 코드 구조의 일관성과 안정성을 높이기 위해 진행하는 중요한 과정입니다. 코드리뷰를 통해 코드 스타일 준수, 잠재적 오류 예방, 성능 개선 등을 이룰 수 있죠.
코드리뷰 진행 시에는 팀 내 컨벤션을 기준으로 하되, 구글의 코드 스타일 가이드를 참고하는 것도 좋습니다. 구글은 다음과 같은 방식으로 코드리뷰를 진행해요.
 change list 준비 후 메일이나 gerrit 같은 코드리뷰 시스템으로 리뷰 신청 리뷰어가 코멘트를 남기는 방식으로 리뷰 진행 코드리뷰는 24시간 내 완료를 원칙으로 함 주요 로직은 unit test로 검증 실험적이거나 버려질 수 있는 코드는 속도 중시 불필요한 공백 제거 코멘트가 code quality 향상을 위한 것인지, 스타일 문제인지 구분  코드리뷰 문서는 누구나 이해할 수 있도록 다음 형식을 유지하는 게 좋아요.</description>
    </item>
    
    <item>
      <title>Sudo 권한 획득(CVE-2021-3156) 취약점 조치방법</title>
      <link>https://happygrammer.github.io/dev/linux/sudo/</link>
      <pubDate>Fri, 09 Apr 2021 21:45:33 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/sudo/</guid>
      <description>sudo 명령어의 -s 또는 -i 옵션을 사용할때 특수 문자 이스케이프시에 로컬 사용자가 root권한을 획득할 수 있는 보안 취약점이 발견 되었다.
 취약점 코드 - CVE-2021-3156 (취약점 명칭은 Baron Samedit라고 명명됨)  권한 없는 로컬 사용자가 인증 없이 root 권한 획득을 할 수 있다. 취약점이 있는 sudo 버전은 다음과 같다.
1.8.2 ~ 1.8.31p2 1.9.0 ~ 1.9.5p1 sudo 버전은 다음 명령어로 확인할 수 있다.
$ sudo -V sudo에 취약점이 있는지를 확인하고 싶다면 다음 명령어를 입력해 확인할 수 있다.</description>
    </item>
    
    <item>
      <title>우주의 이해</title>
      <link>https://happygrammer.github.io/insights/astronomy/universe/</link>
      <pubDate>Sun, 21 Mar 2021 22:58:56 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/astronomy/universe/</guid>
      <description>빅뱅우주론 빅뱅우주론은 13.7 억년전 한점으로 부터 폭발했고, 확장되어 왔다. 우주의 역사를 이해하는 기본적인 핵심은 빛의 속력이 일정하다는 것이다. 1초 지구를 7바퀴 반을 돈다. 빛이 1년간 날아가는 거리는 광년이다. 10억년전, 50억년전의 우주를 보고 있다.
변화하는 우주 우주는 끈임없이 자기 모습을 변화해간다. 모든 별은 생겨나고 자라나고 죽어간다. 일정한 순명을 가지고 있다. 천문학 연구에 의하면, 별들의 수명은 수백만년 ~ 수백억년에 이른다. 밤하늘에 존재하는 별 탄생하는별, 죽어가는 별, 죽어서 별의 잔재들을 확인할 수 있다. 별들을 보면 별의 일생을 논리적으로 이해할 수 있다.</description>
    </item>
    
    <item>
      <title>Git Workflow Diagram</title>
      <link>https://happygrammer.github.io/dev/git-workflow-diagram/</link>
      <pubDate>Sun, 21 Mar 2021 02:13:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git-workflow-diagram/</guid>
      <description>Git을 이용한 버전 관리는 S/W 개발 프로세스 중 하나가 되었습니다. 버전 관리를 이용하면 소스 코드 이력 관리를 통해 안정적인 소스 코드 관리 운용이 가능하지만 능숙한 사용까지 시간이 걸립니다. Git 사용을 돕기 위해 주요 Git 명렁어에 대한 다이어그램을 작성해 보았습니다. 보완이 필요한 점은 피드백 환영 합니다. 감사합니다.</description>
    </item>
    
    <item>
      <title>소프트웨어 라이프사이클</title>
      <link>https://happygrammer.github.io/insights/software-lifecycle/</link>
      <pubDate>Sat, 06 Feb 2021 11:51:28 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/software-lifecycle/</guid>
      <description>프로젝트 진행 단계 소프트웨어를 개발을 시작하려는 사회 초년개발자들은 소프트웨어 라이프 사이클에 익숙하지 안습니다. 업무를 시작하면 프로젝트에 참가하고, 프로젝트는 하나의 라이프 사이클이 존재하고, 투자에 대한 아웃풋과 기간이 분명히 정해져 있습니다. 프로젝트 라이프 사이클 단계를 보면 요청 단계, 제안서 작성 단계, 프로젝트 시작 단계, 그리고 프로젝트 수행 단계, 프로젝트 종료 단계가 있습니다.
첫 번째로 고객 요청 단계에서는 RFP(Request for Proposal)를 고객으로부터 받아요. RFP는 발주자가 특정 과제의 수행에 필요한 요구사항을 체계적으로 정리하여 제시함으로써 제안자가 제안서를 작성하는데 도움을 주기 위한 문서입니다.</description>
    </item>
    
    <item>
      <title>Rust 입문용 치트시트</title>
      <link>https://happygrammer.github.io/rust/cheat-seat/</link>
      <pubDate>Sun, 31 Jan 2021 00:08:17 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/rust/cheat-seat/</guid>
      <description>Rust 입문용 치트시트를 만들게 되어 공유 드립니다. 개선이 필요한 점은 댓글 부탁 드립니다. 다운로드</description>
    </item>
    
    <item>
      <title>의존 구문 분석시 단어간의 관계 태깅</title>
      <link>https://happygrammer.github.io/nlp/dependency-tag-set/</link>
      <pubDate>Sat, 30 Jan 2021 22:30:35 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/dependency-tag-set/</guid>
      <description>의존 구문 분석이 이뤄 지면 문장에서 중심이 되는 요소는 지배소(governor)가 되고 의존소(dependent)는 지배소의 의미를 보완해 주는 역할을 하는 요소이다. 예를 들어 아름다운 한라산에서 한라산이 지배소가 되고 아름다운	이 의존소가 된다. 의존 문법 관점에서 두 단어가 의존 관계에 있는지 그렇지 않은지를 판단할 수 있으며, 만약 두 단어가 의존 관계가 있다면 의존 관계 태그(예:NP_SBJ, VP_MODE 등)를 부착해 두 단어간의 관계를 표시한다. 의존 관계 태그는 정보통신단체표준 문서의 제안에 따라 구문 태그와 기능 태그를 결합해해 사용함을 원칙으로 하고 있다.</description>
    </item>
    
    <item>
      <title>Rust 크로스 컴파일 방법</title>
      <link>https://happygrammer.github.io/rust/problem/cross-compile/</link>
      <pubDate>Sat, 16 Jan 2021 18:34:29 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/rust/problem/cross-compile/</guid>
      <description>특정 OS에서 개발한 프로그램을 다른 OS 환경에서 실행 하고 싶은 경우가 있다. rustup 명령어(rust toolchain installer)를 이용해 대상 OS에 맞는 툴체인을 설치해 크로스 컴파일이 가능하다. 본 글은 맥 OS 환경에서 Rust 프로그램을 Linux와 Windows 플랫폼으로 크로스 컴파일하는 상황을 가정해 작성 하였다.
rustup 명령어 알아보기 rustup 명령어는 러스트 툴체인 인스톨러 명령어이다. 툴체인 설정 관리 기능을 제공한다. rustup 명령어 옵션은 다음과 같다.
$ rustup rustup 1.23.1 (3df2264a9 2020-11-30) The Rust toolchain installer USAGE: rustup [FLAGS] [+toolchain] &amp;lt;SUBCOMMAND&amp;gt; FLAGS: -v, --verbose Enable verbose output -q, --quiet Disable progress output -h, --help Prints help information -V, --version Prints version information ARGS: &amp;lt;+toolchain&amp;gt; release channel (e.</description>
    </item>
    
    <item>
      <title>Precision과 Recall의 이해</title>
      <link>https://happygrammer.github.io/ai/ml/precision-recall/</link>
      <pubDate>Fri, 01 Jan 2021 20:02:08 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/ai/ml/precision-recall/</guid>
      <description>적합 문서 검색엔진의 성능은 적합 문서(relevant document)를 잘 찾는 능력이다. 적합 문서를 잘 찾으려면 적합성을 고려해야 한다. 적합성은 사용자 적합성과 주제 적합성을 고려한다. 사용자 적합성은 사용자에게 맞는 적합한 문서를 찾았는지에 대한 것이다. 예를 들어 질의에 맞는 문서를 찾았지만, 사용자에게 올바른 답변을 줄 수 없는 문서라면 사용자 적합성이 없다고 본다. 주제 적합성은 사용자 질의에 맞는 적합한 문서를 찾았는지에 대한 것이다. 단순 grep과 같은 키워드 일치 만으로 문서를 찾았다면 관련 문서는 찾았지만, 사용자 주제에 맞지 않는 문서가 검색될 수 있다.</description>
    </item>
    
    <item>
      <title>애자일 칸반과 스크럼</title>
      <link>https://happygrammer.github.io/dev/kanban-and-scrum/</link>
      <pubDate>Thu, 31 Dec 2020 11:00:24 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/kanban-and-scrum/</guid>
      <description>칸반과 스크럼의 차이 칸반과 스크럼은 프로젝트 목적 달성을 위해 사용하는 프로세스 도구이다. 스크럼은 럭비에서 차용된 것으로 스크럼은 세 명 이상의 선수가 공을 에워싸고 서로 어깨를 맞대어 버티는 공격 태세를 의미하는데, 팀워크를 강조하기 위한 용어다. 스크럼은 스프린트 기반의 점직적인 개발 방법론 이다. 칸반은 칸반이란 일본어로 카드나 눈에 보이는 기록이라는 것을 뜻한다. 적시생산시스템(Just in time)과 같이 순서가 정해진 공정에서 작업의 순서를 통제하는데 사용된다. 칸반과 스크럼의 차이는 다음과 같다.
    칸반 스크럼     규범 수 많다 적다   역할 구분 없음 Product Owner, Scrum Master, Team   작업 추가 가능 어려움   스프린트 스프린트 수행 여부는 팀이 결정 N번의 스프린트(2~4주) 진행   백로그 우선순위 백로그 우선순위를 고려하지 않음 백로그 우선순위를 고려함   일의 양 결정 X O - 스프린트 마다 일의 양이 결정됨    규범수와 역할 구분 관점에서 보면 이 둘 간의 차이를 알 수 있다.</description>
    </item>
    
    <item>
      <title>Rust if 조건문</title>
      <link>https://happygrammer.github.io/rust/control-if-else/</link>
      <pubDate>Thu, 31 Dec 2020 09:39:24 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/rust/control-if-else/</guid>
      <description>if 문 if 문은 조건이 참인지 거짓인지를 판단하고 분기를 수행한다.
fn main() { let n = 1; if n &amp;lt; 0 { print!(&amp;quot;{}는 음수 입니다.&amp;quot;, n); } else if n &amp;gt; 0 { print!(&amp;quot;{}은 양수 입니다.&amp;quot;, n); } else { print!(&amp;quot;{}은 0입니다.&amp;quot;, n); } } 실행 결과
1은 양수 입니다. 조건부 할당 변수에 초깃값을 할당 할때 다른 언어와 유사하게 삼항 연산자를 이용할 수 있다.
let n = 1; let is_positive = if n &amp;gt; 0 { true } else { false }; // true 위 삼항 연산자는 연산자의 조건이 참과 거짓으로 제한되어 3개 이상의 조건 기술은 깊이 2 이상의 조건 문이 필요하다.</description>
    </item>
    
    <item>
      <title>머신러닝 데이터 관리</title>
      <link>https://happygrammer.github.io/ai/ml/data/</link>
      <pubDate>Thu, 31 Dec 2020 00:24:37 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/ml/data/</guid>
      <description>데이터의 종류 머신 러닝에서 문제 유형에 따라 사용하는 데이터가 다르다. 데이터는 크게 형태에 따라 음성, 이미지, 텍스트로 나뉜다. 이중 텍스트 데이터의 예로 위키피디아 데이터가 있다.
데이터 균형 데이터 양이 많아도 다음 두가지 유형 중 하나의 문제에 속해 있다면 학습이 잘 진행 되지 않을 수 있다.
 레이블링 편중 문제 적은 데이터 문제  레이블링 편중 문제는 데이터 레이블링이 특정 카테고리로 편중되어 학습이 잘 되지 않는 문제다. loss function에 의해 데이터 레이블링이 많이 되어 있는 분류로 편중되어 학습될 수 있다.</description>
    </item>
    
    <item>
      <title>RNN 모델을 확장한 LSTM</title>
      <link>https://happygrammer.github.io/ai/ml/lstm/</link>
      <pubDate>Wed, 30 Dec 2020 23:28:57 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/ml/lstm/</guid>
      <description>LSTM은 RNN 아키텍처를 근간으로 하는 모델이다. RNN(recurrent network) 모델은 입력층-은닉층-출력층으로 이어지는 순방향 신경망(feed-forward network)이다.
이와 달리 LSTM은 feedback 연결을 포함하고 있어 순환 신경망인 특성이 있다.
LSTM은 새로운 입력이 주어지면 셀(cell)이라는 공간에 단어의 상태를 저장한다. 셀은 입력을 담당하는 입력 게이트(input gate), 출력을 담당하는 출력 게이트(output gate), 상태를 잊기 위해 망각 게이트(forget gate)의 역할을 수행한다.
입력 상태는 중요도에 따라 잊을지 말지를 결정해 주어야 한다. 입력 게이트는 입력 상태의 크기를 결정해 기억량의 크기를 결정하며, 망각 게이트는 입력 상태 파라메터에 기억한 상태 파라메터를 곱해 잊을지 말지를 결정한다.</description>
    </item>
    
    <item>
      <title>Linux 권한 관리</title>
      <link>https://happygrammer.github.io/dev/linux/permissions/</link>
      <pubDate>Wed, 30 Dec 2020 16:47:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/permissions/</guid>
      <description>현재 접속 사용자 현재 서버에 접속한 사용자의 id 확인은 users 명령어를 이용해 확인 한다.
$ users user users 명령과 비슷한 명령어로, 사용자의 접속 정보도 함께 볼 수 있는 명령어로 who 와 w 명령어가 있다.
who -H 명령어는 헤더 정보를 포함해 접속 사용자 정보를 표시한다.
$ who -H USER LINE WHEN user console Nov 27 07:09 user ttys000 Dec 8 23:25 user ttys001 Dec 9 19:27 user ttys003 Dec 14 03:35 가능한 많은 정보를 얻기 위해 -aH 옵션을 줄 수 있다.</description>
    </item>
    
    <item>
      <title>방화벽 설정 관리 iptables, firewalld</title>
      <link>https://happygrammer.github.io/dev/linux/iptables_firewalld/</link>
      <pubDate>Wed, 30 Dec 2020 16:47:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/iptables_firewalld/</guid>
      <description>Iptables 명령어를 이용한 방화벽 관리 Iptables 명령어는 Cent OS 6이하에서 사용하는 방화벽 설정 관리 명령이다.
방화벽 설정 확인 후 삭제 방화벽 설정 상태를 보려면 -L 옵션을 이용해 목록을 표시할 수 있다.
# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- anywhere anywhere tcp spt:40050 ACCEPT tcp -- anywhere anywhere tcp spt:40050 iptables -L 옵션을 주었을때 출력되는 prot 열은 프로토콜을 의미하며, 프로토콜의 종류로 tcp, udp, icmp, 또는 all가 있다.</description>
    </item>
    
    <item>
      <title>Linux 기본 관리 명령어</title>
      <link>https://happygrammer.github.io/dev/linux/commands-basic/</link>
      <pubDate>Wed, 30 Dec 2020 12:21:00 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/commands-basic/</guid>
      <description>앨리어스 사용 alias는 명령어를 대체하는 명령어이다. 명령어를 축약해 사용자의 정의 명령어를 정의할 수 있다. alias라고 입력하면 시스템이 정의한 alias 명령어를 확인할 수 있다.
$ alias 디렉터리만 조회하는 명령어는 다음과 같다.
$ ls -l | grep &amp;quot;^d&amp;quot; 용량이 큰 대상부터 출력하는 명령은 다음과 같다.
$ ls - al | sort -rk 5 # 5열(-k)을 기준으로 용량이 큰것 것(-r) 부터 출력 위 명령어는 lsd라는 앨리어스로 등록할 수 있다.
$ alias lsd=&#39;ls -l | grep &amp;quot;^&amp;quot;&#39; 아파치 서버를 시작하거나 종료하는 명령어를 앨리어스를 등록해 두면 편리하다.</description>
    </item>
    
    <item>
      <title>단순함에 대한 명언들</title>
      <link>https://happygrammer.github.io/insights/simple/</link>
      <pubDate>Sun, 22 Nov 2020 21:19:37 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/simple/</guid>
      <description>바보는 사물을 크고 복잡하게 만든다. 반대로 가려면 천재성과 용기가 필요하다. 아인슈타인의 말이다. 삶이란 정말 단순한 것이지만, 우리는 그것을 계속 복잡하게 만들고 있다. 단순하고 평범한 몇개의 원리만 알면 해당 분야의 80%는 소화할 수 있다. 논문이나 전문 분야에서도 그대로 적용된다.
 Everything should be made as simple as possible, but no simpler  모든 것은 더 단순하게 할 수 없을 만큼 가능한 한 단순하게 해야한다. (아인슈타인)   If you can’t explain it simply, you don&#39;t understand it well enough  단순하게 설명할 수 없다면 제대로 이해하지 하지 못한 것이다.</description>
    </item>
    
    <item>
      <title>견고한 코드 설계의 원칙들</title>
      <link>https://happygrammer.github.io/dev/code-design/</link>
      <pubDate>Sat, 21 Nov 2020 09:09:47 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/code-design/</guid>
      <description>코드 설계의 기본 원칙  DRY (Don&#39;t Repeat Yourself)  한번 이상 동일하거나 유사한 코드를 작성하지 않는 것이 좋다.   SCP (Speaking Code Principle)  코드는 그 목적을 전달해야 한다. 코드에 주석을 추가했다는 것은 코드에 불충분한 목적이 있음을 암시 하기도 한다.   TDA (Tell, Don&#39;t Ask)  객체에게 정보를 요구하지 말고 그냥 행위하도록 시키라. (&#39;Law of Demeter&amp;rsquo;와 유사) 데이터 생성 객체(구현 정보 은닉, 캡슐화)로만 하고, 구체적인 타입이나 값은 넘기지 않는다.</description>
    </item>
    
    <item>
      <title>JAVA 멀티 스레드 프로그래밍</title>
      <link>https://happygrammer.github.io/dev/java/multithreading/</link>
      <pubDate>Sun, 18 Oct 2020 09:02:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/multithreading/</guid>
      <description>프로세스는 여러 명령어들의 하나의 실행 단위이다. 스레드는 하나의 프로세스에 존재하는 여러 개의 실행 단위이다. 하나의 스레드 실행은 싱글 스레드라 하며, 여러 스레드의 실행은 멀티 스레드라고 한다.
Thread Class 방식 vs Runnable 방식 thread class 방식은 Thread 클래스를 상속해 스레드를 실행하며, Runnable 방식은 Runnable 인터페이스를 구현해서 실행하는 방식이다.
1. Thread Class 방식 Thread 클래스를 상속해 스레드를 실행하는 예제이다.
class TestThreadByThreadClass extends Thread { public void run() { System.out.println(&amp;#34;스레드 실행중&amp;#34;); } public static void main(String args[]) { TestThreadByThreadClass thread = new TestThreadByThreadClass(); thread.</description>
    </item>
    
    <item>
      <title>Rust 데이터 타입</title>
      <link>https://happygrammer.github.io/rust/data_types/</link>
      <pubDate>Sun, 07 Jun 2020 15:00:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/rust/data_types/</guid>
      <description>Rust는 두개의 서브 데이터 타입이 있다. scalar와 compound이다. Rust는 정적 타입 언어(statically typed language)이다. 따라서 값을 기반으로 타입을 추론할 수 있지만, 모든 변수에 대한 타입을 알아야 컴파일이 가능하다.
Scalar Types Integer Types    Length Signed Unsigned     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    Floating-Point Types fn main() { let x = 2.</description>
    </item>
    
    <item>
      <title>Rust 설치하기</title>
      <link>https://happygrammer.github.io/rust/install/</link>
      <pubDate>Sun, 07 Jun 2020 14:35:56 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/rust/install/</guid>
      <description>리눅스, 맥OS 환경이면 명령 인터페이스 1줄로 Rust 설치가 가능하다.
Rust 설치 명령 Rust 설치는 rustup를 다운로드 하여 설치 하는 명령어이다.
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 설치 과정 Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. It will add the cargo, rustc, rustup and other commands to Cargo&#39;s bin directory, located at: /Users/smarthome/.cargo/bin This can be modified with the CARGO_HOME environment variable.</description>
    </item>
    
    <item>
      <title>중의성의 종류와 중의성 해소</title>
      <link>https://happygrammer.github.io/nlp/hangeul/ambiguitymd/</link>
      <pubDate>Sun, 17 May 2020 21:07:45 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/hangeul/ambiguitymd/</guid>
      <description>중의성은 하나의 언어 표현이 둘 이상의 의미로 해석될 수 있는 언어의 특성을 의미합니다. 중의성은 어휘 중의성과 구조 중의성으로 구분됩니다.
어휘 중의성  동음 이의어 : 차를 준비했다. 1) 자동차를 의미하지만 2) 마시는 차를 의미하기도 한다. 다의어 : 오늘 아침 1) 아침에 일어 났어 2) 아침 먹고 나왔어  &amp;lsquo;동음이의어(同音異義語; homonym)&amp;lsquo;는 소리 같은 단어로, 어원도 다릅니다. 예를 들어 &amp;lsquo;차&#39;는 마시는 차를 의미하기도 하지만, 소리가는 동일하지만 어원 자체가 다른 운송 수단인 &amp;lsquo;차&#39;를 의미하기도 합니다.</description>
    </item>
    
    <item>
      <title>자연어처리/머신러닝 용어집</title>
      <link>https://happygrammer.github.io/nlp/nlp_vocabulary/</link>
      <pubDate>Tue, 07 Apr 2020 00:15:52 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/nlp_vocabulary/</guid>
      <description>본 문서는 자연어처리/머신러닝 용어 목록을 소개합니다.
  Auto ML(Automated machine learning)
 엔지니어의 도움 없이도 머신 러닝 모델을 생성할 수 있는 머신러닝 솔루션 &amp;ldquo;Data 처리, Feature 엔지니어링, Feature 추출, Feature 선택&amp;quot;의 자동화 지원 관련 솔루션  Google Cloud Platform - Cloud AutoML Google Cloud Platform - AutoML NLP Azure - Azure Machine Learning AWS - Amazon SageMaker      Auto Regressive
 AR(순차적인 데이터 처리) 이러한 관점에서 ELmo, GPT를 AR 계열로 볼 수 있음    BERT</description>
    </item>
    
    <item>
      <title>한국의 경제 지표</title>
      <link>https://happygrammer.github.io/insights/statistics/</link>
      <pubDate>Sun, 05 Apr 2020 17:49:27 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/statistics/</guid>
      <description>통계 지표는 현재 한국의 경제 상황을 확인 하는 것이 보다 객관적인 사고를 하는데 도움이 됩니다. 그래서 경제 상황을 이해할 수 있는 몇가지 주요 지표 들에 대해서 확인해 보도록 하겠습니다.
비정규직 비율의 증가 비정규직 근로자와 정규직 근로자 사이에는 임금 등에서 보상의 차이가 존재합니다. 비정규직 비율이 36.4%에 해당합니다. 비정규직의 발생 배경은 경제의 불확실성입니다. 경제의 불확실성으로 인해, 비정규직 비율이 높아지면 기업 관점에서 기술 축적을 방해하고, 노동자 관점에서는 고용불안을 가져다 줍니다. 요즘 코로나 상태로 인해 세계 경제가 꽁꽁 얼어 붙고, 소비가 위축되면서 경제의 불확실성이 높아진 상태입니다.</description>
    </item>
    
    <item>
      <title>본질을 꿰뚫는 통찰력</title>
      <link>https://happygrammer.github.io/insights/insight/</link>
      <pubDate>Sun, 05 Apr 2020 14:39:37 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/insight/</guid>
      <description>기업의 성장 하려면 통찰을 통해 숨은 본질을 파악해 문제를 해결해 나가는 것이 필요하다. 기업에 있어서 본질은 기업의 존립을 좌우하는 핵심 가치이다.
세계적 기업들은 저마다 본질을 추구하고 있다. 구글은 최근 유튜브, 클라우드 서비스 등의 사업 영역을 확장하고 있지만, 구글의 본질은 검색이다. 애플은 아이폰과 같은 혁신 제품을 생산 했지만 컴퓨터 그 이상의 가치를 추구한다. 바로, 심플이다. 애플은 경쟁사 델과 달리 제품군이 단 4가지였지만, 천문학적인 이윤을 달성할 수 있었다. 애플은 고객에게 심플한 구매 경험을 제공함으로서 애플 브랜드를 더욱 신뢰하게 만들었다.</description>
    </item>
    
    <item>
      <title>한글 준말의 규칙성</title>
      <link>https://happygrammer.github.io/nlp/hangeul/abbreviations/</link>
      <pubDate>Thu, 02 Apr 2020 07:56:10 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/hangeul/abbreviations/</guid>
      <description>본말과 준말 준말 준말은 긴말을 의미가 왜곡되지 않으면서 줄인말입니다. 낱말에서 소리가 탈락 되는 위치는 첫소리, 중간 소리, 끝소리, 앞뒤소리가 있습니다.
 첫소리 탈락 예 : 배 안 윗 냄새 - 배 ㄴ 앳 냄새 - 배냇냄새 중간 소리 탈락 예 : 바깥-사돈 - 바ㅌ-사돈 - 밭사돈 끝소리 탈락  어제-저녁 - 어ㅈ 저녁 - 엊저녁 그것 은 - 그거-은 - 그건 허송하지 - 허송치 깨끗하지 - 깨끗지 섭섭하지 - 섭섭지 (한글 맞춤법 40항)  ㄱ,ㄷ,ㅂ 소리가 나는 경우는 &amp;lsquo;하&#39;가 탈락됩니다.</description>
    </item>
    
    <item>
      <title>텐서플로우 아키텍처</title>
      <link>https://happygrammer.github.io/ai/tensorflow/tf-architecture/</link>
      <pubDate>Sun, 29 Mar 2020 18:50:40 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/tf-architecture/</guid>
      <description>텐서플로우는 큰 규모의 분산 기반의 학습과 추론을 고려해 설계 됐습니다. 새로운 기계 학습 알고리즘이 나오더라도 이를 지원할 수 있으며, 시스템 레벨의 최적화도 지원합니다. 다음 그림은 텐서플로우의 아키텍처입니다.
왼쪽은 텐서플로우를 구성하는 컴포넌트들에 대한 그림이며, 오른쪽은 텐서 플로우가 어떠한 방식으로 컴포넌트간의 데이터를 주고 받으면서 실행 되는지를 나타내는 그림입니다.</description>
    </item>
    
    <item>
      <title>Roberta</title>
      <link>https://happygrammer.github.io/ai/papers/roberta/</link>
      <pubDate>Sat, 28 Mar 2020 20:53:21 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/papers/roberta/</guid>
      <description>RoBERTa: A Robustly Optimized BERT Pretraining Approach
언어 모델 프리트레이닝은 상당한 성능 향상을 가져 왔지만, 다른 접근방식 간의 비교는 어렵다. 훈련은 계산 비용이 높은 이유도 있지만, 접근 마다 데이터을 저마다 이용하기 때문이다. 이 논문은 BERT 프리트레이닝(Devlin et al., 2019)의 복제 연구이다. 이 논문은 하이퍼 파라미터 선택이 실험 결과에 많은 영향을 줄 수 있음을 가정하고 있다. 레이블 데이터를 이용해 end-task에 대한 파인 튜닝(finetuned)을 적용한 모델을 만든다다. BERT가 상당히 불충분한 훈련을 받았고, BERT 이후의 모델의 성능은 BERT 모델과 유사하거나, 초과할 수 있다는 점을 지적한다.</description>
    </item>
    
    <item>
      <title>Netty 채널 소개와 채널 핸들러</title>
      <link>https://happygrammer.github.io/netty/handler/</link>
      <pubDate>Sun, 22 Mar 2020 10:10:24 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/netty/handler/</guid>
      <description>채널은 IO 동작(파일, 소켓)을 수행할 수 있는 연결 상태를 의미합니다. Netty에서는 채널 핸들러를 이용해 관심사 분리를 수행합니다.
채널 핸들러 종류    종류      Inbound Handler 입력 데이터(in bound)에 대한 변경 상태를 감시하고 처리하는 역할을 하는 핸들러   Outbound Handler 출력 데이터(out bound)에 대한 동작을 가로채 처리하는 역할을 하는 핸들러    ChannelInboundHandler 메소드    종류 설명     channelRegistered(&amp;hellip;) 채널이 이벤트 루프에 등록됐을때 호출됨   channelUnregistered(&amp;hellip;) 채널이 생성 됐지만, 이벤트 루프에 등록되지 않았을때 호출됨   channelActive(&amp;hellip;) 채널이 활성화 됐을때(peer와 연결됐을때) 호출됨.</description>
    </item>
    
    <item>
      <title>Netty 핵심 컴포넌트</title>
      <link>https://happygrammer.github.io/netty/intro/</link>
      <pubDate>Sat, 21 Mar 2020 21:29:30 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/netty/intro/</guid>
      <description>네티는 자바 기반의 비동기 기반의 네트워크 프레임 워크입니다. 네티는 애플, 트위터, 페이스북, 구글, 인스타그램 등을 포함한 사용자 커뮤니티를 포함해 발전하고 있습니다. 네티는 JAVA 1.6 이상에서 외부 의존성 없이 동작 가능합니다.
1. 채널 채널은 NIO의 기본 구조입니다. 네티는 싱글 쓰레드도 생성된 1개의 셀렉터가 N개의 채널을 관리합니다.
 Thread -&amp;gt; Select -&amp;gt; {채널1, 채널2, 채널3, &amp;hellip;}  셀렉터는 이벤트 리스너 역할을 수행합니다. 클라이언트 요청이 들어 왔거나, 데이터가 도착했을 경우 셀렉터에 알립니다.
[셀렉터를 이용한 Non-blocking I/O]</description>
    </item>
    
    <item>
      <title>맥 OS에서 아파치, PHP 시작 설정</title>
      <link>https://happygrammer.github.io/dev/installing-apache-php-on-macos/</link>
      <pubDate>Sat, 21 Mar 2020 21:15:12 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/installing-apache-php-on-macos/</guid>
      <description>퍼미션 문제가 발생할 수 있어 루트 사용자로 권한을 변경합니다.
sudo su - 맥 OS에서 아파치 시작 apachectl start http://localhost 접속해 서버 페이지 접속이 가능한지 확인합니다.
맥 OS에서 PHP 시작 서버 페이지가 표시 됐다면 서버 시작은 정상적으로 수행된 것 입니다. 서버가 정상적으로 정상적으로 시작 됐더라도 별도 설정을 하지 않으면 PHP 페이지는 출력되지 않습니다. PHP 페이지를 출력하려면 아파치 설정을 수정해야 합니다. 먼저 아파치 설정을 백업해 둡니다. 앞으로 설정이 바뀌더라도 디폴트 설정이 무엇인지 참고할 때 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>도커 컴포즈 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/docker-compose/</link>
      <pubDate>Sun, 01 Mar 2020 08:50:10 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/docker-compose/</guid>
      <description>도커 컴포즈는 여러 컨테이너들의 상태를 관리하는 도구입니다. 일반적으로 도커에서 관리하는 컨테이너 상태는 다음과 같습니다.
 created, restarting, running, removing, paused, exited, dead  이중 도커 컴포즈가 관리하는 상태는 다음과 같습니다. 도커 컴포즈는 도커 데스크탑 for MAC 설치시 이미 포함되어 있어 별도 설치를 하지 않아도 됩니다.
도커 컴포즈 실행 도커 컴포즈는 여러 컨테이너의 실행을 docker-compose.yml 파일을 docker-compose up 명령어로 실행할 수 있게 합니다.
docker-compose 파일에 서비스 정의 docker-compose.yml는 서비스를 정의하는 파일입니다. 도커 컴포즈에 정의한 서비스는 web과 redis입니다.</description>
    </item>
    
    <item>
      <title>도커에 Mariadb 설치</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/mariadb/</link>
      <pubDate>Sun, 01 Mar 2020 00:55:12 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/mariadb/</guid>
      <description>도커 실행 여부 체크 설치를 진행하기 전에 도커 실행 여부를 확인합니다. 도커가 실행중인 상태가 아니면 다음과 같은 예외 메시지가 출력됩니다.
Using default tag: latest Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 지금 부터 mariadb를 다운로드 받아 설정 까지 진행하도록 하겠습니다.
도커 이미지 다운로드 docker pull mariadb 컨테이너 실행 3306 port로 설정해 실행합니다.
docker container run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 --name mariadb mariadb docker 볼륨을 /Users/Shared/data/mariadb로 설정합니다.</description>
    </item>
    
    <item>
      <title>Angular CLI 설치와 프로젝트 설정</title>
      <link>https://happygrammer.github.io/dev/frontend/angular/angular-cli/</link>
      <pubDate>Sat, 29 Feb 2020 18:15:02 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/angular/angular-cli/</guid>
      <description>Angular는 Angular CLI를 이용해 프로젝트 관리의 복잡도를 낮추고 Angular 개발에만 집중할 수 있게 합니다.
Angular CLI 소개와 설치 지금 소개하려는 Angular CLI(Angular Command Line Interface)는 개발자가 Angular 개발에 만 집중할 수 있도록 개발에 필요한 Angular 프로젝트의 설정이나 프로젝트의 전반적인 관리를 명령어 기반으로 수행할 수 있게 지원합니다. Angular CLI가 제공하는 기능은 다음과 같습니다.
■ Angular 프로젝트 생성
■ Angular의 중요 구성요소 추가(컴포넌트, 지시자, 파이프, 서비스)
■ 코드 변경 시 빌드를 수행하고 애플리케이션을 재시작</description>
    </item>
    
    <item>
      <title>crontab을 이용한 스케쥴 관리</title>
      <link>https://happygrammer.github.io/dev/linux/shell/crontab/</link>
      <pubDate>Fri, 28 Feb 2020 10:39:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/crontab/</guid>
      <description>crontab 설정 # ┌───────────── min (0 - 59) # │ ┌────────────── hour (0 - 23) # │ │ ┌─────────────── day of month (1 - 31) # │ │ │ ┌──────────────── month (1 - 12) # │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6는 일~토, 7=일) # │ │ │ │ │ # │ │ │ │ │ # * * * * * &amp;lt;실행할 커맨드&amp;gt; crontab 작업 리스트 $ crontab -l crontab 로그 확인 $ cat /var/log/cron crontab 설정 확인 $ cat /var/spool/cron/&amp;lt;user_id&amp;gt; crontab service 상태 확인과 재실행 $ service crond status crond (pid 2994)를 실행하고 있습니다.</description>
    </item>
    
    <item>
      <title>오리온의 별 베텔게우스</title>
      <link>https://happygrammer.github.io/insights/astronomy/betelgeuse/</link>
      <pubDate>Tue, 25 Feb 2020 06:49:47 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/astronomy/betelgeuse/</guid>
      <description>베텔게우스(Betelgeuse)는 오리온자리의 좌상 꼭짓점에 위치해 있으며, 지름이 9억 6500만㎞로, 태양보다 800배 이상크다. 베텔게우스를 태양계에 두면 목성의 궤도까지 잡아먹을 정도이다.
지구에서 650광년 떨어진 비교적 가까운 거리에 있으며, 망원경으로 표면 특징을 포착할 수 있는 몇 안 되는 별 중 하나이다. 별의 회전 속도가 시속 1만7700~5만3000㎞(미국천문학회 235차 회의에서 발표됨)라고 한다. 별의 밝기가 어두워져서 곧 초신성으로 폭발하게 될 것이 아닌지 하는 소식이 있다. 초신성이 폭발 했다면 650년 후에나 우주의 불꽃 놀이를 볼 수 있다.</description>
    </item>
    
    <item>
      <title>Doc2vec를 이용한 문서의 벡터 변환</title>
      <link>https://happygrammer.github.io/nlp/doc2vec/</link>
      <pubDate>Sun, 23 Feb 2020 17:19:48 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/doc2vec/</guid>
      <description>Doc2Vec(Document Embedding with Paragraph Vectors)은 Word2Vec에서 확장된 알고리즘입니다. Doc2Vec은 다량의 코퍼스를 문서 임베딩시에 훌륭한 성능을 보여줍니다. Word2VecDoc2Vec과 Word2Vec이 무엇이 다른지 다음 표로 정리했습니다.
    Word2Vec Doc2Vec     년도 2013년 2015년   저자 Tomas Mikolov 와 동료들 Andrew M. Dai 와 동료들   feature word vector word vecotr + paragraph vector   주요 모델 CBOWSkip Gram PV-DM modelPV-DBOW    Doc2Vec은 기존 Word2Vec모델을 확장하기 위해 paragraph vector를 제안했습니다.</description>
    </item>
    
    <item>
      <title>Docker 명령어 소개</title>
      <link>https://happygrammer.github.io/dev/cloud/docker/docker/</link>
      <pubDate>Wed, 19 Feb 2020 06:50:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/cloud/docker/docker/</guid>
      <description>기본적인 명령어 컨테이너 확인 docker container ls $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2463b80300ec mariadb &amp;quot;docker-entrypoint.s…&amp;quot; 13 seconds ago Up 12 seconds 0.0.0.0:3306-&amp;gt;3306/tcp mariadb  컨테이너 목록을 표시하는 명령어인 docker ps 는 오래전 방식입니다. 새로운 명령어 형식은 docker container &amp;lt;subcommand&amp;gt;입니다. 즉, docker container ls를 권장합니다. 이때 docker container ls는 docker container ps와 동일한 명령어입니다. 즉 아래 4개 명령어는 정확히 동일 기능을 수행하는 명령어입니다.  실행중인 컨테이너 정보를 표시하는 동일 명령어</description>
    </item>
    
    <item>
      <title>Serving 클라이언트 API</title>
      <link>https://happygrammer.github.io/ai/tensorflow/serving-client-api/</link>
      <pubDate>Tue, 18 Feb 2020 08:00:08 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/serving-client-api/</guid>
      <description>RESTful API In addition to gRPC APIs TensorFlow ModelServer also supports RESTful APIs. This page describes these API endpoints and an end-to-end example on usage.
The request and response is a JSON object. The composition of this object depends on the request type or verb. See the API specific sections below for details.
In case of error, all APIs will return a JSON object in the response body with error as key and the error message as the value:</description>
    </item>
    
    <item>
      <title>Serving 서버 API</title>
      <link>https://happygrammer.github.io/ai/tensorflow/serving-server-api/</link>
      <pubDate>Tue, 18 Feb 2020 08:00:00 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/serving-server-api/</guid>
      <description>TensorFlow 서빙 API 레퍼런스 tensorflow::serving
   Classes      tensorflow::serving::AspiredVersionPolicy An interface for the policy to be applied for transitioning servable versions in a servable stream.   tensorflow::serving::AspiredVersionPolicy::ServableAction Action and the id of the servable associated with it.   tensorflow::serving::AspiredVersionsManager A manager that implements the Target&amp;lt;Loader&amp;gt; API which uses aspired-versions callbacks to dictate which servable versions to load.   tensorflow::serving::AspiredVersionsManager::Options Config options and pluggable objects that will be used by the AspiredVersionsManager.</description>
    </item>
    
    <item>
      <title>서빙 아키텍처 개요</title>
      <link>https://happygrammer.github.io/ai/tensorflow/serving-architecture-overview/</link>
      <pubDate>Tue, 18 Feb 2020 07:45:19 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/serving-architecture-overview/</guid>
      <description>텐서 플로 서빙은 유영하며 머신러닝을 위한 고수준 서빙 모델입니다. 제품 환경을 고려해 디자인 됐습니다. 텐서 플로 서빙은 동일 서버 아키텍처와 API를 유지하고 새로운 알고리즘과 환경을 손쉽게 deploy있습니다. 텐서 플로 서빙은 텐서 플로 모델을 즉시 통합할 수 있고, 다른 타입의 모델과 데이터로 확장할 수 있습니다.
키 컨셉 텐서 플로 서빙 아키텍처 이해를 위해서, 키 컨셉을 이해 할 필요가 있습니다.
Servables
Servables은 텐서 플로 서빙의 주요 개념입니다. Servables은 Servables은 클라이언트가 계산 할 때 사용하는 기본 개체입니다.</description>
    </item>
    
    <item>
      <title>서빙 모델</title>
      <link>https://happygrammer.github.io/ai/tensorflow/serving/</link>
      <pubDate>Tue, 18 Feb 2020 07:39:29 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/serving/</guid>
      <description>텐서 플로 서빙은 유영하며 머신러닝을 위한 고수준 서빙 모델입니다. 제품 환경을 고려해 디자인 됐습니다. 텐서 플로 서빙은 동일 서버 아키텍처와 API를 유지하고 새로운 알고리즘과 환경을 손쉽게 deploy있습니다. 텐서 플로 서빙은 텐서 플로 모델을 즉시 통합할 수 있고, 다른 타입의 모델과 데이터로 확장할 수 있s습니다.
텐서 플로 서빙의 자세한 개발 문서는 아래와 같습니다.
 Architecture Overview Server API REST Client API  </description>
    </item>
    
    <item>
      <title>Meena 논문, 리서치 리뷰</title>
      <link>https://happygrammer.github.io/ai/papers/meena/</link>
      <pubDate>Fri, 14 Feb 2020 01:10:05 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/papers/meena/</guid>
      <description>이 문서는 Meena 논문의 연구 결과를 되짚어 보기 위한 리서치 리뷰 문서이며 새로운 연구 결과를 포함하고 있지 않습니다.
Meena는 멀티턴 도메인 챗봇. end-to-end 방식의 데이터 학습 진행. public 도메인인 소셜 미디어 대화를 대상으로 하였음. 341 GB의 텍스트를 학습하였고 26억(2.6 billions)  파라메터를 사용한 뉴럴넷입니다. 다음 토큰의 perplexity가 최소화 되도록 학습됨.
낮은 perplexity는 샘플에 대해 잘 설명할 수 있는 확률분포를 가졌음을 의미함 OpenAI GPT-2에 비해 1.7배 모델이 크고, 8.5배의 학습 데이터를 사용하였습니다.</description>
    </item>
    
    <item>
      <title>NLP 데이터셋 소개(SQuAD, KoQuAD, KLUE)</title>
      <link>https://happygrammer.github.io/nlp/dataset/</link>
      <pubDate>Mon, 10 Feb 2020 23:38:39 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/dataset/</guid>
      <description>SQuAD 최근에는 기계 독해를 평가하기 위한 SQuAD(The Stanford Question Answering Dataset)와 같은 위키피디아 기반 데이터 셋이 있다. 이 데이터셋은 기계 독해 알고리즘을 객관적으로 평가할 수 있는 벤치마크 데이터 셋으로 알고리즘의 우수성을 평가하기 위해 리더 보드를 운영하고 있다. 전체 데이터셋의 사이이즈는 학습셋=40MB, 개발셋=4MB정도이다.
 https://rajpurkar.github.io/SQuAD-explorer/  SQuAD 2.0 데이터 셋의 구조는 다음과 같다.
{ &amp;quot;version&amp;quot;: &amp;quot;v2.0&amp;quot;, // SQuAD 버전 정보 &amp;quot;data&amp;quot;: [ { &amp;quot;title&amp;quot;: &amp;quot;Normans&amp;quot;, // 출처 문서의 제목 &amp;quot;paragraphs&amp;quot;: [ { &amp;quot;qas&amp;quot;: [ { &amp;quot;question&amp;quot;: &amp;quot;In what country is Normandy located?</description>
    </item>
    
    <item>
      <title>한글에서 사용하는 문장 부호</title>
      <link>https://happygrammer.github.io/nlp/hangeul/punctuation-mark/</link>
      <pubDate>Sun, 09 Feb 2020 10:03:15 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/hangeul/punctuation-mark/</guid>
      <description>문장 부호는 문장간의 관계나 문장 내의 논리 구조를 명시해 정확한 의미 전달에 필요한 부호입니다. 본 글은 2017에 고시된 한글 맞춤법 일부 개정안의 문장 부호들을 소개한 문장 부호 해설을 참고 하였습니다.
문장 부호 표     의미 사용 예제     1. 마침표(.) 서술, 명령, 청유 등을 나타내는 문장 부호의 끝에 사용 제 손을 꼭 잡으세요.   2. 물음표(?) 의문문이나 의문을 나타내는 어구의 끝에 사용 점심 먹었어?</description>
    </item>
    
    <item>
      <title>결합 확률 분포</title>
      <link>https://happygrammer.github.io/ai/data_science/math/probaility/joint-probability/</link>
      <pubDate>Wed, 05 Feb 2020 01:33:53 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/data_science/math/probaility/joint-probability/</guid>
      <description>랜덤 변수 $X, Y, &amp;hellip;,$ 는 확률 공간(probaility space)에 정의됩니다. 여기서 $X, Y$ 는 확률 분포(probability distribution)을 의미합니다. 이들 확률 분포 $X, Y$에 속한 값은 이산 집합 내에 속하거나 특정 범위 내에 속합니다. 이때 두 랜덤 변수 $X, Y$는 이변수 분포(bivariate distribution)입니다.
결합 확률 분포(joint probability distribution)는 결합 누적 분포 함수(joint cumulative distribution function) 또는 결합 확률 밀도 함수(joint probability density function )라고 부르기도 합니다. 결합 화률 분포는 두 분포를 찾는데 사용됩니다.</description>
    </item>
    
    <item>
      <title>한글 9품사 5언</title>
      <link>https://happygrammer.github.io/nlp/hangeul/part-of-speech/</link>
      <pubDate>Sun, 02 Feb 2020 23:03:00 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/hangeul/part-of-speech/</guid>
      <description>품사(part-of-speech)는 공통 성질이 비슷한 분류이며 한글에서는 9품사로 나뉩니다.
명사, 대명사, 수사, 동사, 형용사, 관형사, 부사, 조사, 감탄사 그리고 위 9품사는 문장내의 역할에 따라 5언으로 나뉩니다.
체언, 용언, 수식언, 관계언, 독립언 5언의 역할과 품사 구성은 아래와 같습니다.
   언 역할 품사     체언 문장에서 주어나 목적어 등의 용도로 쓰이는 역할 명사, 대명사, 수사   용언 문장에서 주어의 서술 용도로 쓰이는 역할 동사, 형용사   수식언 문장에서 다른 말을 꾸며주는 역할 관형사, 부사   관계언 체언 뒤에 붙어 문법 관계를 나타내 주거나, 특별한 의미를 더해주는 역할 조사   독립언 감정을 나타내는 역할 감탄사    </description>
    </item>
    
    <item>
      <title>Bag-Of-Words 모델</title>
      <link>https://happygrammer.github.io/nlp/bow/</link>
      <pubDate>Fri, 31 Jan 2020 01:21:05 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/bow/</guid>
      <description>Bag-Of-Words Bag-Of-Word는 순서를 단어 순서를 고려하지 않고 출현 빈도만 고려합니다. Bag-Of-Words 관점에서 &amp;ldquo;the dog bite you&amp;quot;와 &amp;ldquo;you bite the dog&amp;quot;는 어순은 다르지만 동일한 벡터로 표현 되어 동일한 문장으로 취급됩니다. 이들 두 문장에 대한 BoW를 만드는 방법은 두 단계로 진행합니다.
 데이터 준비 : 텍스트를 수집합니다. 그리고 토큰화(tokenize)를 합니다. 어휘 벡터 만들기 : 단어를 토큰화(tokenize) 하여 어휘(vocabulary 벡터(0으로 초기화된 zero 벡터)를 만듭니다. 단어가 문서에 있으면 1, 단어가 문서에 없으면 0으로 표시합니다.  {&amp;quot;the&amp;quot;:1, &amp;quot;dog&amp;quot;:1, &amp;quot;bite&amp;quot;:1 ,&amp;quot;you&amp;quot;,1} {&amp;quot;the&amp;quot;:1, &amp;quot;dog&amp;quot;:1, &amp;quot;bite&amp;quot;:1 ,&amp;quot;you&amp;quot;,1} BoW를 코드로 구현해 보겠습니다.</description>
    </item>
    
    <item>
      <title>자연어 처리란 무엇인가?</title>
      <link>https://happygrammer.github.io/nlp/intro-nlp/</link>
      <pubDate>Wed, 29 Jan 2020 00:37:57 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/intro-nlp/</guid>
      <description>자연어 처리는 컴퓨터가 사람의 언어를 이해하고 컴퓨터와 사람이 상호 작용할 수 있도록 돕는 기술입니다. 자연어 처리의 궁극적인 목표는 컴퓨터가 사람과 같은 언어지능(linguistic Intelligence)을 갖추도록 하는 것 입니다. 언어지능은 사람의 언어 이해하고 다시 사람의 언어로 표현할 수 있는 능력입니다. 컴퓨터가 사람의 언어를 이해하면 사람 처럼 주어진 문제를 해결 하거나 언어에 나타난 말들을 개념화해 생각할 수 있는 추상화 추론(abstract reasoning) 능력도 갖출 수 있게 됩니다.
자연어와 인공어 자연어(natural languge)는 사람이 일상적으로 사용하는 언어이며 사람과 사람이 의사 소통을 위해 자연적으로 발생한 언어입니다.</description>
    </item>
    
    <item>
      <title>MAC 단축키 가이드</title>
      <link>https://happygrammer.github.io/dev/mac/</link>
      <pubDate>Sun, 19 Jan 2020 12:55:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/mac/</guid>
      <description>본 문서는 MAC 단축키를 소개하는 단축키 가이드입니다. 맥 OS를 이용하면서 가장 자주 이용할만한 단축키를 선별해서 소개하는데 목적이 있습니다.
조합키 기호 맥에서 다른 키와 조합시 사용하는 조합키 기호입니다.
command ⌘ shift ⇧ option ⌥ control ⌃
단축키 목록 for MAC    단축키 조합 설명     ⌘ + H 현재 창을 숨김   ⌘ + F3 모든 창을 숨김   ⌘ + TAB 창 사이 이동   ⌘ + W 창 닫기 (⌥옵션 추가하면 전체 창 닫기)   ^ + 방향키 열린창 이동   ⌘ + 번호키 크롬, 사파리 브라우저 사용시 해당 번호에 해당하는 탭으로 이동   ^ + ⇧ + TAB 현재창 종료   ⌘+⌥+I 크롬 소스코드 보기   ⌘+⌥+ESC 프로세스 강제 종료창 띄우기   ⌘ + ` | 현재 프로그램 창 내에서 창전환 |    ⌘+⌥+L 다운로드 폴더 열기   ⌘+⌥+D 독바 숨기기, 보이기    시스템 관리 메뉴 for MAC    맥 이름 윈도우 대응 역할     할성 상태 보기 작업 관리자 프로세스별 CPU, 메모리, 에너지, 디스크, 네트워크 사용율 보기                   VSCode for MAC    맥 이름 윈도우 대응 역할     ⌘⇧F ALT+SHIFT+F 프로세스별 CPU, 메모리, 에너지, 디스크, 네트워크 사용율 보기                   </description>
    </item>
    
    <item>
      <title>BERT 논문, 리서치 리뷰</title>
      <link>https://happygrammer.github.io/ai/papers/bert/</link>
      <pubDate>Thu, 16 Jan 2020 23:41:40 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/papers/bert/</guid>
      <description>이 문서는 BERT 논문의 연구 결과를 되짚어 보기 위한 리서치 리뷰 문서이며 새로운 연구 결과를 포함하고 있지 않다.
BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding BERT라 불리는 새로운 언어 표현 모델를 소개한다. BERT는 &amp;ldquo;Bidirectional Encoder Representations from Transformers&amp;quot;를 의미한다. 최근 언어 표현 모델과 달리 (Peters et al., 2018a; Radford et al., 2018), BERT는 설계 되었다.
 사전 학습(pretrain)으로 deep bidirectional representations을 얻을 수 있다. 이러한 딥 양방향 표현은 레이블이 없는 텍스트로 부터 얻는다.</description>
    </item>
    
    <item>
      <title>PYTORCH 소개</title>
      <link>https://happygrammer.github.io/ai/pytorch/tutorials/tensor_tutorial/</link>
      <pubDate>Thu, 16 Jan 2020 22:09:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/pytorch/tutorials/tensor_tutorial/</guid>
      <description>파이썬 기반의 과학 컴퓨팅 패키지이로 두가지 특징이 있습니다.
 GPU 파워를 사용해 Numpy를 대체 합니다. 딥러닝 연구 플랫폼이며 유연함과 속도를 제공합니다.  텐서 텐서는 NummPy’s ndarrays와 비슷합니다. GPU를 사용해 계산을 가속화할 수 있게 하였습니다.
from __future__ import print_function import torch NOTE
초기화 하지 않은 매트릭스를 선언했고, 사용 되기 전에 알려지지 않은 값을 포함합니다. 초기화 되지 않은 매트릭가 생성되면, 초기화 값된 메트리스가 메모리에 할당됩니다.
빈텐서 생성 empty 메서드를 이용해 5x3 매트릭스를 구축합니다.</description>
    </item>
    
    <item>
      <title>클린코드를 위한 중요 원칙 5가지</title>
      <link>https://happygrammer.github.io/dev/clean-code/</link>
      <pubDate>Thu, 16 Jan 2020 01:17:18 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/clean-code/</guid>
      <description>클린코드를 위한 중요 원칙 5가지가지가 무엇인지에 대해 살펴 보고자 한다.
1. 네이밍 컨벤션 준수 구글의 자바 가이드 와 같은 사례를 참조 하면 좋다. 관례적으로 네이밍 컨벤션은 다음과 같은 원칙을 따르는 것이 좋다.
 클래스명은 명사를 사용하며 의미가 드러나는 이름을 짓는다. 변수는 의도가 드러나는 작성한다. 메서드는 객체의 동작을 의미하므로 동사를 사용하여 이름을 짓는다. 멤버 벼수, 인자명, 로컬 변수명은 lowerCamelCase 방식을 따른다. 상수 변수명은 CONTANT_CASE 방식을 이용한다.  // Constants static final int NUMBER = 5; static final ImmutableList NAMES = ImmutableList.</description>
    </item>
    
    <item>
      <title>날짜와 시간 처리</title>
      <link>https://happygrammer.github.io/dev/linux/shell/date-time/</link>
      <pubDate>Wed, 15 Jan 2020 07:15:14 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/date-time/</guid>
      <description>시간 설정 $ date -s &amp;quot;2020-02-02 04:00:20&amp;quot; 날짜 포맷 출력(기본 포맷) mm/dd/yy형식으로 날짜 출력
date +&amp;quot;%D&amp;quot; 날짜 포맷 출력(지정 포맷) yyyy-mm-dd 형식의 날짜 출력
date &amp;quot;+%Y-%m-%d&amp;quot; echo date # 2020-01-14 시간 출력(기본 포맷) hh-mm-ss 형식의 시간 출력
date +&amp;quot;%T&amp;quot; # 04:09:51 시간 출력(12시간 기준) date +&amp;quot;%r&amp;quot; # 04:09:51 AM 날짜와 시간 출력(기본 포맷) now=$(date) echo $no # 2020년 1월 15일 수요일 05시 19분 36초 MSK 날짜와 시간 출력(지정 포맷) yyyy-mm-dd_hh-mm-ss 형식으로 출력</description>
    </item>
    
    <item>
      <title>중의성의 분류와 중의성 해소</title>
      <link>https://happygrammer.github.io/nlp/wsd/</link>
      <pubDate>Wed, 15 Jan 2020 06:41:24 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/wsd/</guid>
      <description>이 글은 중의성의 종류를 소개하고, 중의성 해소에 필요한 방법을 알아보겠습니다.
중의성의 분류 자연어 처리에서 중의성 해결은 중요한 태스크입니다. 중의성은 하나의 언어 표현이 둘 이상의 해석이 가능한 특성을 의미합니다. 중의성의 종류는 다음과 같습니다.
 어휘 중의성 구조 중의성  어휘 중의성 어휘 중의성 글자나 소리가 동일하지만 의미가 여럿인 중의성입니다. 중의성의 대표적인 예로 동음이의어(homonym)가 있습니다. 동음이의어는 글자는 동일(동형어; homographs)하지만 의미가 다른 단어(다의어; polysemes) 입니다. 동음이의어는 글자로 보면 의미가 구분이 되지 않는 애매성(ambiguity)이 있습니다.</description>
    </item>
    
    <item>
      <title>연비 예측을 위한 회귀 분석</title>
      <link>https://happygrammer.github.io/ai/tensorflow/keras/regression/</link>
      <pubDate>Wed, 15 Jan 2020 06:40:34 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/keras/regression/</guid>
      <description>회귀 문제(regression problem)의 목표는 연속 출력값을 예측하는 것 입니다. 클래스 목록에서 클래스를 선택하는 것이 목표입니다. (사진을 인식해 사과 인지 오렌지를 식별함).
이 노트 북은 고전적인 Auto MPG 데이터셋을 사용하여 모델을 만들고 있는 1970년대 후반부터 1980년데 전반까지의 자동차 연비 예측을 수행합니다. 이를 수행할 목적으로, 저 시기동안 많은 자동차들의 설명(description)을 가지고 구축한 모델을 제공합니다. 이 설명은 다음의 속성을 포함합니다. 예) 실린더, 변위(displacement), 마력(horsepower), 무게
이 예제는 tf.keras API를 사용합니다. 자세한 가이드를 보시면 this guide 글을 보세요.</description>
    </item>
    
    <item>
      <title>한글 표기의 원칙과 자모의 분류</title>
      <link>https://happygrammer.github.io/nlp/hangeul/hangeul-spelling/</link>
      <pubDate>Wed, 15 Jan 2020 06:39:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/hangeul/hangeul-spelling/</guid>
      <description>한글 맞춤법은 말과 글을 올바로 사용하게 만들어, 정보를 올바로 공유할 수 있게 하고 개인과 공동체 내의 의사 소통을 원만하게합니다. 본 문서는 자주 사용될 법한 일반적인 한글 맞춤법의 필수 원칙과 예시들을 소개하는데 있습니다. 이 글은 한글 맞춤법 어문 규정 중요 내용을 소개 하고 한글의 이해를 높이고자 하는 목적으로 작성되었습니다.
1. 한글 표기의 원칙 한글 맞춤법은 한글을 문자로 표기할때의 관례(convention)이자 약속입니다. 한글 맞춤법의 원칙은 표준어를 소리대로 적되, 어법에 맞도록 함을 원칙(제 1항)으로 합니다.</description>
    </item>
    
    <item>
      <title>[쉘스크립트] 텍스트 처리를 위한 쉘 명령어</title>
      <link>https://happygrammer.github.io/dev/linux/shell/text/</link>
      <pubDate>Wed, 15 Jan 2020 06:38:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/shell/text/</guid>
      <description>본 문서는 실무를 하면서 자주 쓰는 리눅스 쉘 명령어 소개하기 위한 목적이 있습니다.
cat 명령어 cat 명령어는 concatenate의 줄임말입니다. 리눅스에서 빈번하게 사용하는 파일 보기 명령어입니다.
기본 문법으로 파일 내용 출력가 있습니다.
$ cat &amp;lt;file-name&amp;gt; 파일 내용을 출력해 특정 파일명으로 저장 할 수 있습니다.
$ cat &amp;lt;file-name&amp;gt; &amp;gt; &amp;lt;output-file-name&amp;gt; 여러 파일 출력이 가능합니다.
cat sample1.txt sample2.txt &amp;gt; sample3.txt 파일 내용 출력시 -n 옵션을 추가하면 줄번호 표시가 가능합니다.
cat -n &amp;lt;file-name&amp;gt; grep 명령어와 조합해서 무자열 필터에 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>1시간 안에 펄(Perl) 언어 익히기</title>
      <link>https://happygrammer.github.io/dev/perl/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/perl/</guid>
      <description>본 포스팅에서 사용한 예제는 다운로드 가능하다. Perl은 고수준의 동적 타입 언어로 csh, Pascal, BASIC-PLUS, PHP, Python 등과 비교되는 언어다. Perl은 쉘 스크립트로 기원했기에 다른 스크립트나 다른 프로그램을 엮어 주는 글루 코드(glue code) 언어로 시스템 관리에도 적합한 언어이다. C, sed, awk 그리고 sh와 같은 언어나 프로그램들의 가장 좋은 점들을 취합한 언어이기도 하다. sed, awk, sh를 사용하여 문제를 풀기 어렵다면 Perl이 대안이 된다. 이외에도 다음과 같은 특징이 있다.
 거의 모든 운영체제에 설치되어 있다.</description>
    </item>
    
    <item>
      <title>파이썬 3 배열과 딕셔너리</title>
      <link>https://happygrammer.github.io/dev/language/python3/python3/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:54 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/language/python3/python3/</guid>
      <description>배열 배열 탐색 token = [s.split() for s in arr] # 공백 단위로 split token = [s.split()[1:] for s in arr] # 공백 단위로 split 딕셔너리 딕셔너리 선언 #!/usr/bin/python3 dict = {&#39;Name&#39;: &#39;Sunflower&#39;, &#39;Kingdom&#39;: &amp;quot;Plantae&amp;quot;, &#39;Class&#39;: &#39;Magnoliopsida&#39;} print (&amp;quot;dict[&#39;Name&#39;]: &amp;quot;, dict[&#39;Name&#39;]) print (&amp;quot;dict[&#39;Kingdom&#39;]: &amp;quot;, dict[&#39;Kingdom&#39;]) print (&amp;quot;dict[&#39;Class&#39;]: &amp;quot;, dict[&#39;Class&#39;]) 딕셔너리 keys 사용 for key in dict.keys(): print(key+&amp;quot;:&amp;quot;+dict[key]) 딕셔너리 메소드    Sr.No. Method &amp;amp; Description     1 dict.</description>
    </item>
    
    <item>
      <title>ProcessBuilder 클래스 - 운영체제 프로세스 생성</title>
      <link>https://happygrammer.github.io/dev/java/processbuilder/</link>
      <pubDate>Wed, 15 Jan 2020 06:35:19 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/java/processbuilder/</guid>
      <description>이전 버전에서는 Runtime.exec()을 이용해 프로세스를 실행할 수 있습니다. 그런데 이 방법은 When Runtime.exec() won&#39;t에서도 소개 됐듯이 표준 입력과 출력에 대한 제한된 버퍼 사이즈로 인해 하위 프로세스가 block 되거나 데드락이 되기도 하는 문제가 있었습니다.
자바 JDK 7 이상에서는 이러한 문제점을 해결 하고자 Proccess Builder 클래스가 소개됩니다. 이 클래스는 운영체제 프로세스 생성할 때 사용합니다. Process Builder 클래스 인스턴스에는 프로세스를 제어할 때 필요한 유용한 속성을 제어합니다. 예를 들어 start() 메서드는 입력 받은 커맨드를 실행해 새로운 프로세스를 생성 합니다.</description>
    </item>
    
    <item>
      <title>영화 리뷰 텍스트 분류</title>
      <link>https://happygrammer.github.io/ai/tensorflow/text_classification_with_hub/</link>
      <pubDate>Wed, 15 Jan 2020 06:34:47 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/text_classification_with_hub/</guid>
      <description>이글은 text_classification_with_hub 한국어 번역 문서입니다.
 Run in Google Colab View source on GitHub Download notebook  노트북은 리뷰 텍스트를 이용해 영화 리뷰을 긍정인지 부정인지를 분류하는 이진 분류를 수행합니다. 머신러닝 문제에 넓게 적용되는 중요한 예제입니다. 튜토리얼은 텐서플로우 허브와 케라스를 이용해 트랜스퍼 러닝(transfer learning)의 기본 응용 방법을 설명합니다.
 역자주 : 트랜스퍼 러닝은 사전 학습 모델(pre-trained mode)을 재사용하여 응용 모델을 구축하는 방법  IMDB 데이터셋 은 5만개의 영화 리뷰(Internet Movie Database)를 포함하고 있습니다.</description>
    </item>
    
    <item>
      <title>Classification</title>
      <link>https://happygrammer.github.io/ai/tensorflow/keras/classification/</link>
      <pubDate>Wed, 15 Jan 2020 06:34:03 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/keras/classification/</guid>
      <description>텐서플로우 튜토리얼(https://www.tensorflow.org/tutorials/quickstart/advanced?hl=ko) 한국어 번역 문서입니다.
분류기의 기본 : 옷 데이터 분류하기 이번 가이드는 옷 이미지(스니커즈나 셔츠) 분류할 수 있는 뉴럴넷 모델을 학습해 보겠습니다. 바로 이해가 되지 않을 수 있지만, 텐서플로우 예제를 보고 빠르게 살펴 보겠습니다. 이 가이드는 tf.keras, 라는 고수준 API를 이용해 모델을 학습합니다.
from __future__ import absolute_import, division, print_function, unicode_literals # TensorFlow and tf.keras import tensorflow as tf from tensorflow import keras # Helper libraries import numpy as np import matplotlib.</description>
    </item>
    
    <item>
      <title>전문가용 텐서플로우 2 튜토리얼</title>
      <link>https://happygrammer.github.io/ai/tensorflow/quickstart-for-experts/</link>
      <pubDate>Wed, 15 Jan 2020 06:32:43 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/quickstart-for-experts/</guid>
      <description>텐서플로우 튜토리얼(https://www.tensorflow.org/tutorials/quickstart/advanced) 한국어 번역 문서입니다.
전문가용 텐서플로우 2 튜토리얼 Google Colaboratory에 노트북 파일이 있습니다. 이 사이트는 파이썬 노트북 파이을 브라우저에서 바로 실행해 볼 수 있어 텐서플로우를 이해하는데 도움을 줍니다. 튜토리얼을 진행해 보겠습니다.
 Colab에서 파이썬 런타임에 접속합니다. 메뉴바의 오른쪽에 위치한 CONNECT을 선택합니다. 메뉴에서 Runtime &amp;gt; Run all을 선택합니다.  텐서플로우 패키지 설치와 임포트 텐서플로우 2 패키지를 다운로드 받고 설치를 진행하고, 텐서플로우를 프로그램으로 임포트합니다.
from __future__ import absolute_import, division, print_function, unicode_literals import tensorflow as tf from tensorflow.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://happygrammer.github.io/about/</link>
      <pubDate>Wed, 15 Jan 2020 06:32:17 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/about/</guid>
      <description>안녕하세요, 해피그(happyg:rammer)입니다! 사용자의 관점에서 AI 모델과 서비스를 개발하는 개발자로서, 저는 항상 사용자의 고민을 어떻게 해결할 수 있을지, 그들의 소중한 시간을 어떻게 아껴줄 수 있을지에 대해 고민합니다. 사용자 중심 개발의 핵심은 사용자의 니즈를 깊이 이해하고, 그들의 경험을 개선하는 데 초점을 맞추는 것입니다. 이를 위해서는 사용자와 끊임없이 소통하고, 그들의 피드백을 귀담아 듣는 것이 중요합니다.
리처드 파인만의 말을 빌리자면,
 &amp;ldquo;I was born not knowing and have had only a little time to change that here and there.</description>
    </item>
    
    <item>
      <title>조선 최고의 메모광 다산 정약용</title>
      <link>https://happygrammer.github.io/insights/jeong-yak-young/</link>
      <pubDate>Wed, 15 Jan 2020 06:31:12 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/jeong-yak-young/</guid>
      <description>기록은 남겨야 보존된다. 메모하지 않으면 기억의 저장고에서 깊은 잠에 빠지고 만다. 생각은 메모를 통해서만 싹을 틔운다. 메모의 습관은 꾸준한 연습 없이는 몸에 잘 붙지 않는다. 밥 먹듯이 메모하고, 숨 쉬듯이 메모해야 습관이 된다. 무심코 기록한 일기가 사료가 되고, 한 시대의 소중한 증언이 된다. 말은 항상 떠돌지만, 기록은 남기는 자를 통해서만 보존된다. 기록되는 순간 그것은 비로소 제 생명을 갖는다.
옛사람의 메모벽 옛사람의 메모벽은 자못 유난스럽다. 책을 읽다가 번뜩 떠오른 생각이 있으면 메모지에 옮겨 적었다.</description>
    </item>
    
    <item>
      <title>스티브잡스, Stay Hungry. Stay Foolish</title>
      <link>https://happygrammer.github.io/insights/steven-jobs/</link>
      <pubDate>Wed, 15 Jan 2020 06:30:21 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/steven-jobs/</guid>
      <description>하는 일을 사랑하는 것 여러분이 진정으로 만족하는 유일한 길은 여러분 스스로 훌륭하다고 믿는 일을 하는 것입니다. 그리고 훌륭한 일을 하는 유일한 길은 여러분이 하는 일을 사랑하는 것입니다. 만일 그것을 아직 찾지 못했다면, 계속 찾으십시오. 주저앉지 마십시오. 언젠가 그것을 발견할 때 여러분은 마음으로부터 그것을 알게 될 것입니다.
마음과 직관을 따라가는 용기 시간은 한정되어 있습니다. 그러므로 다른 사람의 삶을 사느라고 시간을 허비하지 마십시오. 다른 사람들의 견해가 여러분 자신의 내면의 목소리를 가리는 소음이 되게 하지 마십시오.</description>
    </item>
    
    <item>
      <title>텐서플로우 2 입문자용 튜토리얼</title>
      <link>https://happygrammer.github.io/ai/tensorflow/quickstart-for-beginners/</link>
      <pubDate>Wed, 15 Jan 2020 06:29:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/ai/tensorflow/quickstart-for-beginners/</guid>
      <description>텐서플로우 튜토리얼(https://www.tensorflow.org/tutorials/quickstart/beginner) 한국어 번역 문서입니다.
텐서플로우 2 입문 튜토리얼  Google Colab에서 실행 GitHub 소스 보기 노트북 다운로드  케라스를 사용한 짧은 소개  이미지를 분류하는 뉴럴 네트워크(neural network)를 빌드합니다. 빌드된 뉴럴 네트워크를 이용해 학습(Train)을 진행합니다. 마지막으로, 모델의 정확도(accuracy)를 평가합니다.  Google Colaboratory에 노트북 파일이 있습니다. 이 사이트는 파이썬 노트북 파이을 브라우저에서 바로 실행해 볼 수 있어 텐서플로우를 이해하는데 도움을 줍니다. 튜토리얼을 진행해 보겠습니다.
 Colab에서 파이썬 런타임에 접속합니다. 메뉴바의 오른쪽에 위치한 CONNECT을 선택합니다.</description>
    </item>
    
    <item>
      <title>Hugo 정적 사이트 생성기 가이드</title>
      <link>https://happygrammer.github.io/dev/hugo/</link>
      <pubDate>Wed, 15 Jan 2020 06:27:50 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/hugo/</guid>
      <description>Hugo는 Go언어로 만들어진 정적 사이트 생성기(static site generator)입니다. Go언어로 만들어져서 정적 파일 생성이 빠르고 최근 많은 인기를 얻고 있습니다.
변수 사전 정의 변수
 {{ .Title }} 사용자 정의
{{ $address }} 템플릿 가져 오기 파셜 템플릿 가져오기
{{ partial &amp;quot;header.html&amp;quot;}} 템플릿 룩업 순서 layouts/posts/single.html.html가 layouts/posts/single.html보다 우선 순위가 높습니다.
베이스 템플릿 layouts/_default
위 디렉터리에 접근해보면 베이스 템플릿인 baseof.html가 존재합니다. 디폴트 리스트 템플릿인 list.html 파일이 존재합니다.
템플릿 템플릿 설치는 https://themes.gohugo.io/ 사이트를 이용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>1시간 안에 Git 익히기</title>
      <link>https://happygrammer.github.io/dev/git/</link>
      <pubDate>Mon, 06 Jan 2020 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/git/</guid>
      <description>Git은 분산 버전 관리 시스템으로 리눅스 토발즈가 만들었으며 파일의 변경사항을 추적하고 관리할 수 있습니다.
1. Git 설치  GIt 설치 : https://git-scm.com/downloads Github : 깃허브는 Git을 지원하는 웹 호스팅 서비스 Github Desktop : https://desktop.github.com/, Github을 편리하게 이용할 수 있도록 만든 소프트웨어  2. Git을 이용한 형상 관리 http://nvie.com/posts/a-successful-git-branching-model/
3. Git 쉘 명령어 기본 명령어  git init: 깃 저장소를 초기화한다. git help: 깃 명령어를 확인한다. git status: 저장소 상태 정보 표시(저장소에 존재하는 파일, 커밋이 필요한 변경 사항, 현재 브랜치 위치 등)  상태 상태라면 &amp;quot;your branch is up-to-date with &#39;origin/master&#39;&amp;quot;와 같이 표시    사용자 설정  git config &amp;ndash;global user.</description>
    </item>
    
    <item>
      <title>1시간 안에 Vi 익히기</title>
      <link>https://happygrammer.github.io/dev/vi/</link>
      <pubDate>Mon, 06 Jan 2020 01:26:13 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/vi/</guid>
      <description>vi 에디터는 유닉스 에디터다. 터미널에서 쉘이나 각종 txt 파일, 스크립트를 수정할때 종종 사용한다. 단축키를 알아 두면 터미널 작업시 도움이 된다. 많은 명령어가 있지만 본 포스팅은 자주 쓰는 명령어만 추가해 두었다.
실행  view filename : 읽기전용으로 vi filename : 에디팅모드로 파일을 연다.  커서이동   ^ : 문장 시작으로 (또는 0)
  $ 문장 끝으로
  gg : 문서 시작으로
  :$ 문서 끝으로
  :숫자 해당 라인으로</description>
    </item>
    
    <item>
      <title>NLP 개발의 여정</title>
      <link>https://happygrammer.github.io/nlp/the-journey-of-nlp-development/</link>
      <pubDate>Wed, 01 Jan 2020 20:19:26 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/nlp/the-journey-of-nlp-development/</guid>
      <description>자연어 처리(NLP)는 인간의 언어를 컴퓨터가 이해하고 처리할 수 있도록 하는 인공지능의 한 분야입니다. NLP의 역사는 1940년대로 거슬러 올라가는데요, 그 발전 과정을 함께 살펴보겠습니다.
1949년, 워런 위버(Warren Weaver)는 &amp;ldquo;Translation&amp;rdquo; 이라는 보고서에서 기계 번역의 가능성을 제시했습니다. 이는 NLP 연구의 시발점이 되었죠. 이후 1950년대에는 Georgetown-IBM 실험으로 러시아어를 영어로 자동 번역하는 데 성공했습니다.
1960년대에는 ELIZA라는 대화형 시스템이 등장했는데, 이는 제한된 패턴 매칭 기반이었지만 인간과 컴퓨터의 상호작용 가능성을 보여주었습니다. 1970년대에는 챗봇 PARRY가 개발되어 정신분열증 환자와 비슷한 대화를 수행할 수 있게 되었죠.</description>
    </item>
    
    <item>
      <title>ICONV 인코딩 형식 변환</title>
      <link>https://happygrammer.github.io/dev/linux/iconv/</link>
      <pubDate>Wed, 01 Jan 2020 17:53:20 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/linux/iconv/</guid>
      <description>iconv 명령어는 입력 파일의 인코딩을 지정한 인코딩으로 변경할 수 있는 명령어(/usr/bin/iconv)이다.
EUC KR을 UTF 8로 변경 iconv 명령어에 -c 옵션을 이용해 컨버팅이 되지 않는 문자열은 무시 하도록 할수 있다. 아래 명령어는 euc-kr에서 utf-8로 변경하는 명령이다.
iconv -c -f euc-kr -t utf-8 FILE_EUCKR.txt &amp;gt; FILE_UTF8.txt UTF-8을 EUC-KR로 변경 iconv -c -f utf-8 -t euc-kr FILE_UTF8.txt &amp;gt; FILE_EUCKR.txt ICONV 옵션    옵션 설명     -c 변환할 수 없는 문자는 버림   -f ENCODING, &amp;ndash;from-code=ENCODING 입력 파일의 인코딩   -t ENCODING, &amp;ndash;to-code=ENCODING 출력 파일의 인코딩   &amp;ndash;list, -l 지원하는 인코딩 목록들을 출력   &amp;ndash;output, -o file 변환 내용을 터미널 추력 대신 지정한 파일로 출력   &amp;ndash;silent, -s 경고 메시지를 출력하지 않음   &amp;ndash;verbose 자세한 상태 정보를 출력    ICONV &amp;ndash;help 옵션 상세 내용 $ iconv --help Usage: iconv [OPTION.</description>
    </item>
    
    <item>
      <title>수학이 우리에게 필요한 이유</title>
      <link>https://happygrammer.github.io/insights/interesting-mathematics/</link>
      <pubDate>Wed, 01 Jan 2020 01:33:53 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/insights/interesting-mathematics/</guid>
      <description>본 글은 조선일보에 실린 세계수학자대회 개막 기사의 중요 내용을 옮겨 보았다. 이 글이 좋았던 점은 수학이 왜 우리에게 필요한지, 수학 교육의 방향을 어때야 하는지, 수학자들에게 수학이라는 것이 어떤 의미였는지를 옅볼 수 있었던 기사였기 때문이다.
수학 응용에 대한 역사  구글은 검색엔진에 이용하였다. 토이스토리는 컴퓨터 그래픽의 조절기술, 애니메이션에 기하학·미분 적용, 제작비 등 줄여 아폴로 11호는 지구를 떠난 후, 뉴턴 수학을 이용해 어느 지점에서 가속을 해야 달의 궤도에 정확히 들어갈 수 있는지 계산해 냈다.</description>
    </item>
    
    <item>
      <title>@Controller와 @RestController 어노테이션</title>
      <link>https://happygrammer.github.io/dev/backend/spring/mvc-restful/</link>
      <pubDate>Wed, 20 Nov 2019 06:37:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/backend/spring/mvc-restful/</guid>
      <description>@Controller 어노테이션을 이용한 MVC 패턴 MVC는 @Controller에 기반해 작동하는 View 기반의 기술이며, REST는 @RestController 어노테이션을 이용해 객체 데이터 응답 기술입니다. 아래 그림은 전통적인 MVC 패턴 방식의 처리 과정을 보여주고 있습니다.
스프링은 사용자 요청에 대해 Dispatcher Servlet는 최종 처리 결과로 View를 Return해줍니다. DispatchServlet은 아래 각 하위 요소들을 호출함으로서 클라이언트에 최종 http 응답을 만듭니다. URI가 입력되는 Handler mapping을 이용해 컨트롤러로 연결해 줍니다. 컨트롤러에서는 MovelAndView 객체를 View Resolver로 반환합니다. View Resolver는 ModelAndView 객체를 이용해 View를 생성합니다.</description>
    </item>
    
    <item>
      <title>Spring Boot 시작하기</title>
      <link>https://happygrammer.github.io/dev/backend/spring/spring-boot/</link>
      <pubDate>Wed, 20 Nov 2019 06:37:32 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/backend/spring/spring-boot/</guid>
      <description>스프링 부트는 쉽게 제품 등급의 독립형 스프링 기반 애플리케이션을 만들 수 있습니다. 대부분의 스프링 부트 애플리케케이션은 적은 설정을 필요로 합니다.
특징  독립형 애플리케이셩 생성 내장 톰캣, 제티 포함. (WAR파일 배포 불필요) 스타터는 단순한 빌드 설정을 이용합니다. Spring 및 타사 의존 라이브러리를 자동으로 설정 되도록 합니다. 운영에 필요한 health 체크, 외부 설정 등의 기능을 제공합니다. 코드를 생성하거나 XML 설정을 요구 하지 않습니다.  스프링 부트 소개 이 문서는 레퍼런스 문서의 번역 문서입니다.</description>
    </item>
    
    <item>
      <title> 희소성의 원칙</title>
      <link>https://happygrammer.github.io/insights/economics/</link>
      <pubDate>Sun, 03 Jun 2018 15:07:58 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/economics/</guid>
      <description>희소성은 경제학 이론의 출발이다. 사람의 욕망에 비하여 그것을 충족 시켜주는 수단이 양적이나 질적으로 유한하여 부족한 상태를 이르는 말이다.
기회비용 경제학은 한정적인 자원을 가장 효율적으로 배분하는 것을 연구하는 학문이다. 하나를 택하면 하나를 버려야 한다.  그래서 세상에 공짜 점심은 없다고 말한다. 어떤 선택을 위해 포기한 모든 것을 경제학에서는 기회비용이라고 부른다. 예를 들어서 식당을 운영하다가 영하를 보러 갔다가 해보자. 영화 비용으로 쓴 1만원은 명시적인 비용이고, 식당 운영 수익은 암묵적 비용이다. 회계사 관점에서 영화 비용으로 쓴 1만원을 기회 비용이라고 계산한다.</description>
    </item>
    
    <item>
      <title>디자인패턴 적용 Guide</title>
      <link>https://happygrammer.github.io/dev/design-pattern/</link>
      <pubDate>Sat, 02 Jun 2018 23:32:10 +0300</pubDate>
      
      <guid>https://happygrammer.github.io/dev/design-pattern/</guid>
      <description>디자인 패턴이란 특정 컨텍스트 내에서 주어진 문제에 대한 해결책이다. 어떤 컨텍스트 내에서 일련의 제약조건에 의해 영향을 받을 수 있는 문제에 봉착했다면, 그 제약조건 내에서 목적을 달성하기 위한 해결책을 찾아낼 수 있는 디자인을 적용한다. 디자인 패턴의 과다한 사용은 불필요하게 복잡한 코드를 초래할 수 있다. 항상 가장 간단한 해결책으로 목적을 달성할 수 있도록 하고, 반드시 필요할 때만 디자인 패턴을 적용하자. 코딩할 때 어떤 패턴을 사용하고 있는지 주석으로 적어주자. 클래스와 메서드 이름을 만들 때도 사용 중인 패턴이 분명하게 드러날 수 있도록 해보자.</description>
    </item>
    
    <item>
      <title>짧은순으로 정렬한 격언</title>
      <link>https://happygrammer.github.io/insights/proverb/</link>
      <pubDate>Fri, 03 Jun 2016 07:28:33 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/insights/proverb/</guid>
      <description>개발자 격언 중에 변수명은 짧을수록 좋다라는 말이 있다. 쉽고 짧은 격언은 기억하기 쉽고 일깨움을 준다.
 Keep oaring. 계속 노를 저어라. None of your lips. 신소리 마라 All or nothing. 전부냐, 無냐. Walls have ears. 벽에도 귀가 있다. Finding&#39;s keeping. 찾는 것이 갖는 것 Make haste slowly. 급할수록 신중히. The more the merrier. 많을수록 즐겁다. Store is no sore. 저장은 고통이 아니다. Resolve lasts three days. 작심 삼일 Time tries truth.</description>
    </item>
    
    <item>
      <title>Use_strict</title>
      <link>https://happygrammer.github.io/dev/frontend/javascript/use_strict/</link>
      <pubDate>Fri, 28 Nov 2014 08:17:03 +0900</pubDate>
      
      <guid>https://happygrammer.github.io/dev/frontend/javascript/use_strict/</guid>
      <description>use strict 키워드는 ECMAScript 언어 사양(5번째 버전)에 포함되어 있다. ECMA스크립트는 ECMA-262에 의해 표준화된 언어의 이름이다. 자바스크립트와 J스크립트는 모두 ECMA스크립트와의 호환을 목표로 하면서, ECMA 규격에 포함되지 않는 확장 기능을 제공한다. 자바스크립트 라이브러리를 보다보면 strict mode 키워드를 만나볼 수 있다. strict mode는 자바스크립트를 좀더 엄격하게 다루고자 하는 의미이다.
Strict Mode를 사용하는 두가지 이유   모듈화 작업시 모호한 변수선언에 대해 제한과 엄격한 규칙을 통한 오류 발생 가능성을 낮춘다.
  전역변수와 지역변수간 Scope에 따른 변수 충돌을 방지할 수 있다.</description>
    </item>
    
  </channel>
</rss>