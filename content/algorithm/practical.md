---
title: "Practical"
date: 2021-10-01T23:09:31+03:00
draft: true
---

## 실용적인 알고리즘

실용적인 알고리즘을 찾고, 이들 알고리즘을 통해 생각하는 법을 익히는 것이 실무에서 도움이 되리라 생각하다.이 원론적인 `점화식`이니 하는 것은 너무 자세히는 고려하지 않으려 한다. 알고리즘과 관련해서 자주 나오게 되는 주제에 대해서 생각해 보면 다음과 같다.

- 그래프 탐색
- 문자열 검색
- 정렬

### 그래프 탐색

그래프 탐색 문제는 출발 지점에서 도착 지점까지 가기 위해 필요한 최단 경로를 찾는 문제이다. 이러한 예로 미로 찾기, 네비게이션, 친구 찾기등이 있다. 이들 중 네비게이션 프로그램은 출발지와 도착지가 있고 이를 연결하는 효율적인 비용으로 도착지까지 갈 수 있는 최단 경로를 찾는 프로그램이다. 최단 경로로 도착 하려면 전략이 있어야한다. 대표적으로 BFS와 DFS 알고리즘이있다.

DFS는 깊이 우선 탐색 방법으로, 그래프 탐색시 모든 노드를 탐색을 수행하고 더이상 탐색을 수행하지 못하게 되면 분기 지점 부터 다시 탐색을 수행하는 알고리즘이다. BFS 알고리즘은 루트로 부터 시작해 가장 가까운 인접 노드를 탐색하는 방법이다. 



### 문자열 검색

문자열 검색은 `검색`과 관련한 분야에서 사용할 수 있다. 문자열 매칭은 원시적인 방법으로 검색할 문자열을 순차적으로 대칭하면서 찾는 방법이다. A[1...n]의 텍스트 문자열에 패턴 문자열 P[1..m]을 포함하는지를 확인하는 것이다. 패턴은 총 n-m+1번을 비교하면 된다.

```
basicMatching()
{
    for i=1 to n-m+1{ // (1)
        if(P[1...m] = A[i...i+m-1]){ // (2)
            then A[i]에서 매칭됨
        }
    }
}
```

(1) for 루프는 n-m+1회 반복이 이뤄진다. (2) 문자열 비교는 m 길이의 문자열 비교해 O(m)시가이 든다. 따라서 전체 시간은 대략 O(mn)만큼 소요된다. 위와 같은 기술 방법은 다소 우아한 면이 있지만 위와 같은 단순한 패턴 매칭 검색은 프로그래밍의 함수만으로 처리됨을 알 수 있다.

```
"hello world".index("world") // 6
```

문자열의 개수가 100만개이고 여기에서 빠르게 원하는 위치들을 찾아 순위화 하여 보여 주려면 어떻게 해야할까? 

`KMP(knuth-morris-pratt) 알고리즘`을 생각해 보자. 이 알고리즘은 세 사람의 이니셜을 따서 만들었다. apple의 prefix와 suffix와 같은 정보들로 사전에 탐색 했던 정보들을 기반으로 건너 뛸 수 없을까?

KMP 알고리즘이 문자열에서 'abc' 키워드를 찾는 과정

```
kmpSearch
    int n = src.size(), m = search.size();
    
    while(begin <= n - m){
        // keyword가 일치하는 경우 1씩 증가(begin+match)
        // 불일치하는 경우 begin을 1 증가함 ++begin;
        // 접두사를 탐색하거나, 접미사가 있는 경우 begin 증가 처리
    }
    
    return ret;
}
```

