<!DOCTYPE html>
<html>
<head>
    <title>Spring Boot 시작하기</title>
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="Spring Boot 시작하기" />
    
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://happygrammer.github.io/dev/backend/spring/spring-boot/" />
    
    <meta property="og:image" content="https://happygrammer.github.io/thumnail.jpg" />
    <meta name="twitter:image" content="https://happygrammer.github.io/thumnail.jpg" />

    <script src="https://happygrammer.github.io/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

    <link rel="shortcut icon" href="/favicon.ico">
    <link href="https://happygrammer.github.io/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="https://happygrammer.github.io/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://happygrammer.github.io/css/style.css">
    
    <meta name="generator" content="Hugo 0.62.0" />
</head>


<body>
<div id="container">
	<div id="fb-root"></div>
	
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="https://happygrammer.github.io/">해피그</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">About</a>
                
                <a class="main-nav-link" href="/ai">AI</a>
                
                <a class="main-nav-link" href="/dev">Dev</a>
                
                <a class="main-nav-link" href="/insights">Insights</a>
                
                <a class="main-nav-link" href="/mlops">MLOps</a>
                
                <a class="main-nav-link" href="/nlp">NLP</a>
                
                <a class="main-nav-link" href="/rust">Rust</a>
                
		</nav>
            <nav id="sub-nav">
		<div id="search-form-wrap"></div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            
            <div><a href="/dev/" class="archive-article-date">&lt; Devs</a></div>
            
            <h1 class="article-title" itemprop="name">Spring Boot 시작하기</h1>
        </header>
        
        <div class="article-meta">
            <a href="/dev/backend/spring/spring-boot/" class="article-date">
                <time datetime='2019-11-20T06:37:32.000&#43;03:00' itemprop="datePublished">2019-11-20</time>
            </a>
            
            
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            <p><code>스프링 부트</code>는 쉽게 제품 등급의 독립형 스프링 기반 애플리케이션을 만들 수 있습니다. 대부분의 스프링 부트 애플리케케이션은 적은 설정을 필요로 합니다.</p>
<h2 id="heading">특징</h2>
<ul>
<li>독립형 애플리케이셩 생성</li>
<li>내장 톰캣, 제티 포함. (WAR파일 배포 불필요)</li>
<li>스타터는 단순한 빌드 설정을 이용합니다.</li>
<li>Spring 및 타사 의존 라이브러리를 자동으로 설정 되도록 합니다.</li>
<li>운영에 필요한 health 체크, 외부 설정 등의 기능을 제공합니다.</li>
<li>코드를 생성하거나 XML 설정을 요구 하지 않습니다.</li>
</ul>
<h3 id="--">스프링 부트 소개</h3>
<p>이 문서는 레퍼런스 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/getting-started.html#getting-started">문서</a>의 번역 문서입니다. 스프링 부트의 목표는 다음과 같습니다.</p>
<ul>
<li>스프링 개발을 위한 빠르게 넓게 접근할 수 있는 스프링 개발 경험을 제공</li>
<li>프로젝트 공통에 해당하는 특징을 제공함 예를 들어 내장 서버, 보안, 메트릭, 헬스 체크, 외부 설정</li>
<li>XML 설정을 요구하거나 코드 생성이 없음</li>
</ul>
<p>스프링 부터는 다음의 내장 서블릿 컨테이를 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Servlet Version</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Tomcat 9.0</td>
<td align="left">4.0</td>
</tr>
<tr>
<td align="left">Jetty 9.4</td>
<td align="left">3.1</td>
</tr>
<tr>
<td align="left">Undertow 2.0</td>
<td align="left">4.0</td>
</tr>
</tbody>
</table>
<h3 id="---1">스프링 부트 시작</h3>
<p>프로젝트 생성 후 Dependencies로 JDBC가 있다면 아래와 같은 메시지가 뜨면서 실행이 안될 것 입니다.</p>
<pre><code>***************************
APPLICATION FAILED TO START
***************************

Description:

Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.

Reason: Failed to determine a suitable driver class
</code></pre><p>JDBC 설정을 바로 하지 않을 것이라면 다음 애노테이션을 추가합니다.</p>
<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
</code></pre><p>예제를 시작 하겠습니다. 프로젝트 우클릭후 Run As - Spring Boot App을 선택합니다.</p>
<pre><code>package com.example.demo.com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@SpringBootApplication
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})

public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
</code></pre><p>그리고 브라우저를 이용해 다음 주소로 접속합니다.</p>
<pre><code>http://localhost:8080/login
</code></pre><p>만약 디폴트 포트인 8080을 8081로 변경하려면 애플리케이션 프로퍼티에 포트 설정을 합니다.</p>
<pre><code>server.port=8081
</code></pre><p>@SpringBootApplication는 다음 세가지를 합한 의미입니다.</p>
<pre><code>@SpringBootConfiguration
@ComponentScan
@EnableAutoConfiguration
</code></pre><p>@ComponentScan은  각종 @Component를 상속 받는 각종 애노테이션(@Configuration, @Repository, @Service, @Controller, @RestController )을 빈으로 인식해 스캔하는 역할을 합니다.</p>
<h4 id="---2">빈 이름 출력</h4>
<pre><code>package main;

import java.util.Arrays;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class })
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

	@Bean
	public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
		return args -&gt; {
			System.out.println(&quot;Let's inspect the beans provided by Spring Boot:&quot;);
			String[] beanNames = ctx.getBeanDefinitionNames();
			Arrays.sort(beanNames);
			for (String beanName : beanNames) {
				System.out.println(&quot;BeanName : &quot; + beanName);
			}
		};
	}
}
</code></pre><p>빈 이름 목록 출력 결과입니다.</p>
<pre><code>Let's inspect the beans provided by Spring Boot:
BeanName : application
BeanName : applicationTaskExecutor
BeanName : basicErrorController
BeanName : beanNameHandlerMapping
BeanName : beanNameViewResolver
BeanName : characterEncodingFilter
...(중략)
BeanName : webServerFactoryCustomizerBeanPostProcessor
BeanName : websocketServletWebServerCustomizer
</code></pre><h3 id="-">서블릿 컨테이너</h3>
<p>서블릿 컨테이너인 톰캣은 요청을 받아 SpringDispatcherServlet  객체로 전달합니다. 이후 컨트롤러의 액션 메소드로 dispatch를 하게 됩니다. dispatch 수행시 URL과 파라메터와 일치하는 메소드를 찾고 없다면 페이지 없음 응답을 내보냅니다. 액션 메소드를 찾았다면 뷰 이름을 찾습니다. 뷰가 JSP라면 서블릿 컴파일러(tomcat embed-jasper)로 컴파일 후 톰캣이 해당 서블릿을 실행 하도록 합니다. 요약하면 다음 순서로 실행합니다.</p>
<pre><code>JSP → JSTL(서블릿 코드로 변환) → 톰캣(서블릿실행)
</code></pre><p>[서블릿 예제 코드]</p>
<pre><code>import javax.servlet.http.*;
import javax.servlet.*;
import java.io.*;

public class HelloServlet extends HttpServlet{
public void doGet(HttpServletRequest req,HttpServletResponse res)
throws ServletException,IOException
{
    res.setContentType(&quot;text/html&quot;);//컨텐츠 타입 설정
    PrintWriter pw=res.getWriter();//데이터 쓰기위한 스트림 가져옴

    // 스트림을 이용해 컨텐츠를 출력함
    pw.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);
    pw.println(&quot;Hello Servlet&quot;);
    pw.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);

    pw.close();// 스트림을 닫음
}}
</code></pre><h3 id="hello-jsp-">Hello JSP 출력</h3>
<p>JSP 출력을 위해서 pom.xml에 의존성을 추가합니다. 아래 추가한 <a href="https://www.oracle.com/technetwork/java/index-jsp-135995.html">JSTL</a>은 Oracle에서 제공하는 표준 태그 라이브러리입니다. 즉 JSP에서 사용하는 표준 태그를 지원하기 위한 라이브러리입니다. <code>tomcat-embed-jasper</code>은 JSP파일은 서블릿으로 변환하는 컴파일러입니다. 톰캣은 JSP가 서블릿으로 변환되면, 해당 서블릿을 실행합니다. 해당 의존성을 추가하지 않으면 서블릿으로 변환되지 않고 출력됩니다.</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><h4 id="---">포트 설정, 뷰 설정</h4>
<p>이후 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html">애플리케이션 프로퍼티 파일</a> <code>src/main/resources/applicaton.properties</code>에 뷰 설정을 합니다.</p>
<pre><code>spring.mvc.view.prefix=/WEB-INF/views/ # 디폴트 JSP 파일 위치
spring.mvc.view.suffix=.jsp # view의 확장자.
</code></pre><p>애플리케이션 프로퍼티 파일이 아니라 코드를 이용해 <code>@Configuration</code> 애노테이션을 이용합니다.</p>
<pre><code>@Configuration
public class SpringConfig {

	@Bean
	public ViewResolver getViewResolver() {
		InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
		viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
		viewResolver.setSuffix(&quot;.jsp&quot;);
		return viewResolver;
	}
}

</code></pre><p>위 <code>/WEB-INF/views	</code>의 스프링부트 프로젝트의 실재 경로는 아래와 같습니다.</p>
<pre><code>/src/main/webapp/WEB-INF/views
</code></pre><p>위 위치에 hello.jsp 파일을 만듭니다.</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Hell Spring
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="--1">컨트롤러 설정</h4>
<p>Hello 컨트롤러 클래스를 추가하고, 컨트롤러 애노테이션을 추가합니다.</p>
<pre><code>@Controller
</code></pre><p>이때 @RequestMappin 애노테이션을 이용해 위에서 만들어둔 hello.jsp 응답을 하도록 합니다.</p>
<pre><code>package example.boot;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {
	
	@RequestMapping(&quot;/hello&quot;)
    public String jsp() throws Exception {
        return &quot;hello&quot;;
    }

}
</code></pre><p>그리고 브라우저를 이용해 아래 URL을 이용해 접속해서 hello.jsp 응답 결과인 <code>Hello Spring</code>가 출력된 것을 확인합니다.</p>
<pre><code>http://localhost:8080/hello
</code></pre><h3 id="---3">에러 페이지 처리</h3>
<p>페이지가 존재하지 않을 경우 에러 페이지를 커스텀 마이징 할 수 있습니다. ErrorController 크래스를 상속 받아 커스텀 에러 컨트롤러를 구현해 줍니다.</p>
<pre><code>package example.boot;

import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;

@Controller
public class CustomErrorController implements ErrorController {

    private static final String ERROR_PATH = &quot;/error&quot;;

    @Override
    public String getErrorPath() {
        return ERROR_PATH;
    }

    @RequestMapping(value = ERROR_PATH)
    public String error(HttpServletRequest servletReq) {
        Object status = servletReq.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        if (status != null) {
            Integer statusCode = Integer.valueOf(status.toString());
            if(statusCode == HttpStatus.NOT_FOUND.value()) {
                return &quot;errors/404&quot;;
            }
            else if(statusCode == HttpStatus.INTERNAL_SERVER_ERROR.value()) {
                return &quot;errors/500&quot;;
            }
        }
        return &quot;errors/default&quot;;
    }
}
</code></pre><p>위 예제에도 나와 있지만 커스텀 에러 페이지는 다음 경로에 만듭니다.</p>
<pre><code>/src/main/webapp/WEB-INF/views/errors/404
/src/main/webapp/WEB-INF/views/errors/500
/src/main/webapp/WEB-INF/views/errors/default
</code></pre><h3 id="mustache--">Mustache 템플릿 사용</h3>
<p>스프링부트에서  JSP는 권장 사항이 아닙니다. 다음과 같은 이유입니다.</p>
<ul>
<li>war로 배포해야 합니다. (java -jar로 실행은 가능함)</li>
<li>Undertow(JBoss EAP 7에 새롭게 도입된 자바 언어로 작성된 웹서버)는 JSP를 지원하지 않습니다.
<ul>
<li>톰캣만 사용한다면 문제 없음</li>
</ul>
</li>
<li>사용자 재정의 에러 페이지가 적용되지 않을 수 있습니다.</li>
</ul>
<p>따라서 JSP 외의 템플릿 엔진을 도입할 필요가 있습니다. 한가지 대안이 바로 <a href="https://www.thymeleaf.org/documentation.html">Mustache</a>입니다.</p>
<h4 id="mustache---1">Mustache 템플릿 사용하기</h4>
<p>애플리케이션 프로퍼티 파일에 설정해 줍니다.</p>
<pre><code>spring.mustache.prefix=/WEB-INF/views/
spring.mustache.suffix=.html
</code></pre><p>이후 mustache 템플릿을 만듭니다. 경로는 <code>/src/main/webapp/WEB-INF/views/mustache.html</code>로 만들었습니다.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;{{ title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
	{{ msg }}
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>위 mustache.html를 연결해줄 컨트롤러를 만듭니다.</p>
<pre><code>package example.boot;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class MustacheController {
	
	@RequestMapping(&quot;/mustache&quot;)
    public String jsp(Model model) throws Exception {
		model.addAttribute(&quot;title&quot;, &quot;Mustache Test Title&quot;);
		model.addAttribute(&quot;msg&quot;, &quot;Hello Mustache!&quot;);
        return &quot;mustache&quot;;
    }

}

</code></pre><p><code>http://localhost:8080/mustache</code>주소를 호출해 보면 <code>Hello Mustache!</code>라는 문자열이 브라우저에 표시됩니다.</p>
<h3 id="----1">스프링 오류 처리 프로퍼티</h3>
<pre><code>server.error.include-exception : 오류 응답에 exception 포함 여부 (TRUE, FALSE)
server.error.include-stacktrace : 오류 응답에 stacktrace 포함 여부 (ALWAYS, NEVER, ON_TRACE_PARAM)
server.error.path : 오류 응답을 처리할 핸들러(ErrorController)의 path
server.error.whitelabel.enabled : 화이트라벨 페이지 사용여부 (TRUE, FALSE)
</code></pre><p>기본 폴더 구조</p>
<pre><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 404.html
             +- &lt;other templates&gt;
</code></pre>
	    
	    <div class="fb-comments" data-href="https://happygrammer.github.io/dev/backend/spring/spring-boot/" width="100%" data-width="" data-numposts="3"></div>
	</div>

        
        
        <div class="article-toc" >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#heading">특징</a>
      <ul>
        <li><a href="#--">스프링 부트 소개</a></li>
        <li><a href="#---1">스프링 부트 시작</a></li>
        <li><a href="#-">서블릿 컨테이너</a></li>
        <li><a href="#hello-jsp-">Hello JSP 출력</a></li>
        <li><a href="#---3">에러 페이지 처리</a></li>
        <li><a href="#mustache--">Mustache 템플릿 사용</a></li>
        <li><a href="#----1">스프링 오류 처리 프로퍼티</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
        
        
	


        
    </div>
    <nav id="article-nav">
    
    <a href="/dev/backend/spring/mvc-restful/" id="article-nav-newer" class="article-nav-link-wrap">
        <div class="article-nav-title"><span>&lt;</span>&nbsp;
            @Controller와 @RestController 어노테이션
        </div>
    </a>
    
    
    <a href="/insights/economics/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title"> 희소성의 원칙&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>

</article>

        
    </section>
    <footer id="footer">
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css" integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
